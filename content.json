{"meta":{"title":"博客","subtitle":"技术博客","description":"许贵荣","author":"许贵荣个人版权所有","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringBoot官方文档翻译（三十一）：定制Banner","slug":"Spring BootDoc第四部分/SpringBoot翻译（三十一）定制Banner","date":"2018-04-24T12:45:47.000Z","updated":"2018-04-24T13:00:54.379Z","comments":true,"path":"2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（三十一）定制Banner/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（三十一）定制Banner/","excerpt":"","text":"23.2 Customizing the Banner（定制Banner）123456789The banner that is printed on start up can be changed by adding a banner.txt file to your classpath or by setting the spring.banner.location property to the location of such a file. If the file has an encoding other than UTF-8, you can set spring.banner.charset. In addition to a text file, you can also add a banner.gif, banner.jpg, or banner.png image file to your classpath or set the spring.banner.image.location property. Images are converted into an ASCII art representation and printed above any text banner. 当应用启动的时候显示的那个Banner是可以被放在类路径下的banner.txt所改变，或者通过设置spring.banner.location属性来指定bannner的位置。如果该banner文件的编码格式不是UTF-8，您可以通过设置spring.banner.charset来指定编码格式。除了text文件以外，您还可以指定一个banner.gif格式的文件，或者banner.jpg或者banner.png的图片文件到您类路径下，或者通过设置spring.banner.image.location属性来指定该图片位置。图片被转换成ASCII艺术表示并在上面打印任何文字横幅。1Inside your banner.txt file, you can use any of the following placeholders: 在banner.txt文件中，您可以使用以下任何占位符： 属性 描述 ${application.version} 您应用的版本信息,诸如定义在MANIFEST.MF中的。举个例子,Implementation-Version: 1.0 则打印1.0. ${application.formatted-version} The version number of your application, as declared in MANIFEST.MF and formatted for display (surrounded with brackets and prefixed with v). For example (v1.0).","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第四部分","slug":"SpringBoot官方文档翻译第四部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第四部分/"}]},{"title":"SpringBoot官方文档翻译（三十）：启动失败","slug":"Spring BootDoc第四部分/SpringBoot翻译（三十）启动失败","date":"2018-04-24T12:30:47.000Z","updated":"2018-04-24T12:12:32.735Z","comments":true,"path":"2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（三十）启动失败/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（三十）启动失败/","excerpt":"","text":"23.1 Startup Failure（启动失败）12345If your application fails to start, registered FailureAnalyzers get a chance to provide a dedicated error message and a concrete action to fix the problem. For instance, if you start a web application on port 8080 and that port is already in use, you should see something similar to the following message: 如果您的应用启动失败了，注册的FailureAnalyzers将获得有机会提供专门的错误信息和具体行动解决问题。举个例子，如果您子啊端口8080启动一个应用，而此端口已经被使用了，将会出现如下信息：1234567891011***************************APPLICATION FAILED TO START***************************Description:Embedded servlet container failed to start. Port 8080 was already in use.Action:Identify and stop the process that&apos;s listening on port 8080 or configure this application to listen on another port. 12Spring Boot provides numerous FailureAnalyzer implementations, and you can add your own. Spring Boot提供了众多的FailureAnalyzer实现，您可以加入您自身的实现。 1234If no failure analyzers are able to handle the exception, you can still display the full conditions report to better understand what went wrong. To do so, you need to enable the debug property or enable DEBUG logging for org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener. 如果没有错误分析器能够处理这个异常，依然可以展示整个的条件报告去了解到底什么出错了。这样做，您需要为以下包或者类开启debug属性或者开启DEBUG日志：org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener 12For instance, if you are running your application by using java -jar, you can enable the debug property as follows: 举个例子，如果您使用java -jar去运行您的应用，您能够通过开启debug属性，如下：1$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第四部分","slug":"SpringBoot官方文档翻译第四部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第四部分/"}]},{"title":"SpringBoot官方文档翻译（二十九）：Spring Boot的功能","slug":"Spring BootDoc第四部分/SpringBoot翻译（二十九）Spring Boot的功能","date":"2018-04-24T11:55:47.000Z","updated":"2018-04-24T12:03:07.305Z","comments":true,"path":"2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（二十九）Spring Boot的功能/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第四部分/SpringBoot翻译（二十九）Spring Boot的功能/","excerpt":"","text":"Part IV. Spring Boot features（Spring Boot的功能）12345This section dives into the details of Spring Boot. Here you can learn about the key features that you may want to use and customize. If you have not already done so, you might want to read the &quot;Part II, “Getting Started”&quot; and &quot;Part III, “Using Spring Boot”&quot; sections, so that you have a good grounding of the basics. 本章节将介绍SPirng Boot的细节，您可以学习到你想使用和定制的关键功能。如果您还没有准备好，您可以阅读第二部分“Getting Started”和第三部分“Using Spring Boot”章节，这样您可以具备良好的基础知识。 23. SpringApplication1234The SpringApplication class provides a convenient way to bootstrap a Spring application that is started from a main() method. In many situations, you can delegate to the static SpringApplication.run method, as shown in the following example: SpringApplication类提供了一个非常便捷的方式通过main（）方法去启动Spring应用。在大多数情况下，您可以通过委托给静态方法SpringApplication.run（）去启动，如下：123public static void main(String[] args) &#123; SpringApplication.run(MySpringConfiguration.class, args);&#125; 12When your application starts, you should see something similar to the following output: 当您的应用启动后，您将看到如下的景象：123456789101112 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: v2.1.0.BUILD-SNAPSHOT2013-07-31 00:08:16.117 INFO 56603 --- [ main] o.s.b.s.app.SampleApplication : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)2013-07-31 00:08:16.166 INFO 56603 --- [ main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy2014-03-04 13:09:54.912 INFO 41370 --- [ main] .t.TomcatServletWebServerFactory : Server initialized with port: 80802014-03-04 13:09:56.501 INFO 41370 --- [ main] o.s.b.s.app.SampleApplication : Started SampleApplication in 2.992 seconds (JVM running for 3.658) 1234By default, INFO logging messages are shown, including some relevant startup details, such as the user that launched the application. If you need a log level other than INFO, you can set it, as described in Section 26.4, “Log Levels”, 默认情况下，INFO级别的日志将会展示出来，包括一些相应的启动细节，诸如启动程序的用户等。如果您需要展示不仅仅是INFO级别的日志，您可以设置它，详情参照26.4章节“Log Levels”。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第四部分","slug":"SpringBoot官方文档翻译第四部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第四部分/"}]},{"title":"SpringBoot官方文档翻译（二十八）：生产环境打包","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十八）生产环境打包","date":"2018-04-24T10:55:47.000Z","updated":"2018-04-24T10:54:33.955Z","comments":true,"path":"2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十八）生产环境打包/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十八）生产环境打包/","excerpt":"","text":"21. Packaging Your Application for Production（生产环境打包）12Executable jars can be used for production deployment. As they are self-contained, they are also ideally suited for cloud-based deployment. 可运行的jars包能够被用于生成环境部署。由于它们是独立的，它们也非常适合基于云的部署。123For additional “production ready” features, such as health, auditing, and metric REST or JMX end-points, consider adding spring-boot-actuator. See Part V, “Spring Boot Actuator: Production-ready features” for details. 对于其他的“生产就绪”的功能，诸如健康检测，审计，REST风格埋点或者JMX的断点，考虑引入spring-boot-actuator。参照第五部分，“Spring Boot Actuator: Production-ready features”获取更多的细节。 22. What to Read Next（接下去读什么）1234You should now understand how you can use Spring Boot and some best practices that you should follow. You can now go on to learn about specific Spring Boot featuresin depth, or you could skip ahead and read about the “production ready” aspects of Spring Boot. 目前您已经知道如何使用Spring Boot和一些您需要遵守的最佳实践。您可以继续学习Spring Boo的一些特殊的特性。或者您也可以越过这些去切入阅读Spring Boot的“生产准备”。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十七）：远程应用","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十七）远程应用","date":"2018-04-24T09:25:47.000Z","updated":"2018-04-24T09:21:19.644Z","comments":true,"path":"2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十七）远程应用/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十七）远程应用/","excerpt":"","text":"20.5 Remote Applications(远程应用）12345The Spring Boot developer tools are not limited to local development. You can also use several features when running applications remotely. Remote support is opt-in. To enable it, you need to make sure that devtools is included in the repackaged archive, as shown in the following listing: Spring Boot的开发者工具不仅仅局限于本地开发，您同样可以使用一些远程应用运行时的功能。远程支持为可选项。去开启它，您需要确认devtools已经被引入到重新打包的包中，如下：1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 12Then you need to set a spring.devtools.remote.secret property, as shown in the following example: 然后您需要设置spring.devtools.remote.secret属性，如下：1spring.devtools.remote.secret=mysecret 12Enabling spring-boot-devtools on a remote application is a security risk. You should never enable support on a production deployment. 远程开启spring-boot-devtools是一项安全风险。您在生产环境应该永远不要开启这项功能。12345Remote devtools support is provided in two parts: a server-side endpoint that accepts connections and a client application that you run in your IDE. The server component is automatically enabled when the spring.devtools.remote.secret property is set. The client component must be launched manually. 远程devtools通过两部分来提供支持：一个是服务端的断点接受连接，一个客户端应用能够运行于您的IDE。spring.devtools.remote.secret如果被设置，服务端的组件会自动的开启。客户端组件必须手动启动。 20.5.1 Running the Remote Client Application（运行远程客户端应用）1234The remote client application is designed to be run from within your IDE. You need to run org.springframework.boot.devtools.RemoteSpringApplication with the same classpath as the remote project that you connect to. The application’s single required argument is the remote URL to which it connects. 远程客户端的设计是为了能够从您本地IDE运行。您需要设置org.springframework.boot.devtools.RemoteSpringApplication与您连接的远程应用同样的类路径。您连接应用唯一需要的参数即远程URL。12For example, if you are using Eclipse or STS and you have a project named my-app that you have deployed to Cloud Foundry, you would do the following: 举个例子，如果您使用Eclipse或者STS并且您有一个名为my-app的工程，您部署在云端，您需要做如下的操作：12345• Select Run Configurations… from the Run menu.• Create a new Java Application “launch configuration”.• Browse for the my-app project.• Use org.springframework.boot.devtools.RemoteSpringApplication as the main class.• Add https://myapp.cfapps.io to the Program arguments (or whatever your remote URL is). 从Run菜单选择Run Configurations… 从“launch configuration”中创建一个新的java应用 浏览my-app项目 使用org.springframework.boot.devtools.RemoteSpringApplication作为主class 增加https://myapp.cfapps.io作为程序运行参数（或者您的远程URL）1A running remote client might resemble the following listing: 一个运行成功的远程客户端应用应该如下:12345678910111213 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ ___ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | | _ \\___ _ __ ___| |_ ___ \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| []::::::[] / -_) ' \\/ _ \\ _/ -_) ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | |_|_\\___|_|_|_\\___/\\__\\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote :: 2.1.0.BUILD-SNAPSHOT2015-06-10 18:25:06.632 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)2015-06-10 18:25:06.671 INFO 14938 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy2015-06-10 18:25:07.043 WARN 14938 --- [ main] o.s.b.d.r.c.RemoteClientConfiguration : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.2015-06-10 18:25:07.074 INFO 14938 --- [ main] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292015-06-10 18:25:07.130 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105) 1234Because the remote client is using the same classpath as the real application it can directly read application properties. This is how the spring.devtools.remote.secret property is read and passed to the server for authentication. 因为远程客户端正在使用与实际相同的类路径,它可以直接读取应用程序的属性.这是spring.devtools.remote.secret如何被服务端读取并通过的授权的方式。12It is always advisable to use https:// as the connection protocol, so that traffic is encrypted and passwords cannot be intercepted. 应用一直是以https://作为连接协议，所以报文是被加密并且密码不能够被拦截的。123If you need to use a proxy to access the remote application,configure the spring.devtools.remote.proxy.host and spring.devtools.remote.proxy.port properties. 如果您需要使用代理进入远程应用，配置spring.devtools.remote.proxy.host和spring.devtools.remote.proxy.port属性。 20.5.2 Remote Update（远程更新）123456The remote client monitors your application classpath for changes in the same way as the local restart. Any updated resource is pushed to the remote application and (if required) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle. 远程客户端监视您的类路径下的改变与本地重启相似。任何资源的额更新将会被推到远程应用中，并且（如果需要的话0触发重启。这个对于您本地没有，而在云服务端运行的服务很有帮助。通常，远程更新和重启比整个重新编译部署生命周期更短。123Files are only monitored when the remote client is running. If you change a file before starting the remote client, it is not pushed to the remote server. 文件仅在远程客户端运行的时候才会被监控到。如果您在启动远程客户端之前改变文件，它将不会被推送到远程服务器上。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十六）：已知限制&LiveReload&全局设置","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十六）已知限制&LiveReload&全局设置","date":"2018-04-24T08:59:47.000Z","updated":"2018-04-24T08:47:46.933Z","comments":true,"path":"2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十六）已知限制&LiveReload&全局设置/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十六）已知限制&LiveReload&全局设置/","excerpt":"","text":"20.2.7 Known Limitations（已知限制）1234Restart functionality does not work well with objects that are deserialized by using a standard ObjectInputStream. If you need to deserialize data, you may need to use Spring’s ConfigurableObjectInputStream in combination with Thread.currentThread().getContextClassLoader(). 重新启动功能不适用于那些通过使用标准的ObjectInputStream进行反序列化的对象。如果您需要反序列化数据，你可能需要使用Spring的ConfigurableObjectInputStream结合使用Thread.currentThread（）.getContextClassLoader（）。123Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you need to request a fix with the original authors. 不幸的是，一些第三方的库反序列化的时候未考虑容器类加载器。如果您发现了这个问题，您需要请求作者做相应的修改。 20.3 LiveReload1234The spring-boot-devtools module includes an embedded LiveReload server that can be used to trigger a browser refresh when a resource is changed. LiveReload browser extensions are freely available for Chrome, Firefox and Safari from livereload.com. spring-boot-devtools模块引入了内置LiveReload服务器，当一个资源发生改变时，能够触发浏览器自动刷新，LiveReload浏览器扩展对于Chrome和Firefox还有Safari提供免费支持（livereload.com）。12If you do not want to start the LiveReload server when your application runs, you can set the spring.devtools.livereload.enabled property to false. 如果您子在您的应用运行的时候不想启动LiveReload服务器，您可以通过spring.devtools.livereload.enabled属性来设置成false。1234You can only run one LiveReload server at a time. Before starting your application, ensure that no other LiveReload servers are running. If you start multiple applications from your IDE, only the first has LiveReload support. 您一次只能运行一个LiveReload服务器。在启动您的应用之前，确保没有其他的LiveReload服务器在运行。如果您在IDE中运行多个应用，仅仅第一个运行的应用能够有LiveReload的效果。 20.4 Global Settings（全局设置）123456You can configure global devtools settings by adding a file named .spring-boot-devtools.properties to your $HOME folder (note that the filename starts with “.”). Any properties added to this file apply to all Spring Boot applications on your machine that use devtools. For example, to configure restart to always use a trigger file, you would add the following property: 您可以通过增加名为.spring-boot-devtools.properties（注意文件名以.开头的）的文件到您的$HOME文件夹来配置全局的devtools设置。任何属性被增加到这个文件将会被应用生效到所有的您机器上使用devtools的Spring Boot应用中。举个例子，去配置重启使用一个触发文件，您可以增加如下属性： ~/.spring-boot-devtools.properties.1spring.devtools.reload.trigger-file=.reloadtrigger","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十五）：使用触发文件&定制“重启”类加载器","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十五）使用触发文件&定制“重启”类加载器","date":"2018-04-24T07:59:47.000Z","updated":"2018-04-24T07:53:37.491Z","comments":true,"path":"2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十五）使用触发文件&定制“重启”类加载器/","link":"","permalink":"http://yoursite.com/2018/04/24/Spring BootDoc第三部分/SpringBoot翻译（二十五）使用触发文件&定制“重启”类加载器/","excerpt":"","text":"20.2.5 Using a Trigger File（使用触发文件）1234567If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times. To do so, you can use a “trigger file”, which is a special file that must be modified when you want to actually trigger a restart check. Changing the file only triggers the check and the restart only occurs if Devtools has detected it has to do something. The trigger file can be updated manually or with an IDE plugin. 如果您使用持续编译更改文件的IDE，您可能更愿意仅在特定时间触发重新启动。如果那样的话，您可以使用一个“触发文件”，当您需要触发重启的时候，您必须通过修改这个特殊的文件触发。这个文件的改变仅仅触发检查并且只是重启Devtools已经发现需要做的一些事情。这个触发文件能够被手动更新或者通过IDE的插件更新。12To use a trigger file, set the spring.devtools.restart.trigger-file property to the path of your trigger file. 想使用这个触发文件，设置spring.devtools.restart.trigger-file属性到您的触发文件。12You might want to set spring.devtools.restart.trigger-file as a global setting, so that all your projects behave in the same way. 您也许想要设置set spring.devtools.restart.trigger-file为一个全局的设置，那样的话您所有的项目都能通过这样的方式统一行为。 20.2.6 Customizing the Restart Classloader（自定义重启类加载器）1234As described earlier in the Restart vs Reload section, restart functionality is implemented by using two classloaders. For most applications, this approach works well. However, it can sometimes cause classloading issues. 如前重启和重载章节所述，重启功能是由两个类加载器来实现的。对于大多数应用，这种方式工作正常。然而，它有时候也会导致一些类加载问题。12345By default, any open project in your IDE is loaded with the “restart” classloader, and any regular .jar file is loaded with the “base” classloader. If you work on a multi-module project, and not every module is imported into your IDE, you may need to customize things. To do so, you can create a META-INF/spring-devtools.properties file. 默认情况下，任何您使用IDE打开的项目都是被“重启”类加载器加载，并且任何常规的.jar文件都会被“base”类加载器加载。如果您在一个多模块工作的项目中，并且并不是所有的模块都是导入到您的IDE，您也许需要定制一些东西。为此，您可以创建一个META-INF/spring-devtools.properties文件。1234567The spring-devtools.properties file can contain properties prefixed with restart.exclude and restart.include. The include elements are items that should be pulled up into the “restart” classloader, and the exclude elements are items that should be pushed down into the “base” classloader. The value of the property is a regex pattern that is applied to the classpath, as shown in the following example: spring-devtools.properties文件能够包含前缀为restart.exclude和restart.include属性。include元素项目将会被拉取到“重启”类加载器中，“exclude”元素项目将会提交至“base”类加载器。这些属性的值是一个应用于类路径的正则表达式模式，如下：12restart.exclude.companycommonlibs=/mycorp-common-[\\\\w-]+\\.jarrestart.include.projectcommon=/mycorp-myproj-[\\\\w-]+\\.jar 12All property keys must be unique. As long as a property starts with restart.include. or restart.exclude. it is considered. 所有的属性keys必须是唯一的。只要属性的前置是restart.include或者restart.exclude就会被考虑到。123All META-INF/spring-devtools.properties from the classpath are loaded. You can package files inside your project, or in the libraries that the project consumes. 所有类路径下的META-INF/spring-devtools.properties都将会被加载。您可以打包文件进入您的项目或者在项目依赖的lib库中。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十四）：监控额外的路径&禁用重启","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十四）监控额外的路径&禁用重启md","date":"2018-04-23T09:24:47.000Z","updated":"2018-04-23T09:06:24.754Z","comments":true,"path":"2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十四）监控额外的路径&禁用重启md/","link":"","permalink":"http://yoursite.com/2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十四）监控额外的路径&禁用重启md/","excerpt":"","text":"20.2.3 Watching Additional Paths（监控额外的路径）1234567You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath. To do so, use the spring.devtools.restart.additional-paths property to configure additional paths to watch for changes. You can use the spring.devtools.restart.exclude property described earlier to control whether changes beneath the additional paths trigger a full restart or a live reload. 有时候，当您修改的文件不在类路径下的时候，您可能也需要您的应用重启或者重载。这样做，使用spring.devtools.restart.additional-paths属性去配置额外的路径去监控它是否发生了改变，并根据这个改变去重启。您可以使用spring.devtools.restart.exclude属性，如前所述控制额外路径下的更改是否触发完整重新启动或实时重新加载。 20.2.4 Disabling Restart（禁用重启）12345If you do not want to use the restart feature, you can disable it by using the spring.devtools.restart.enabled property. In most cases, you can set this property in your application.properties (doing so still initializes the restart classloader, but it does not watch for file changes). 如果您不喜欢用重启功能，您可以通过spring.devtools.restart.enabled属性禁用它。在大部分情况下，您可以在您的application.properties中设置它。（如果设置了它，始终会初始化“重启”类加载器，但是不监控文件的修改）。1234If you need to completely disable restart support (for example, because it does not work with a specific library), you need to set the spring.devtools.restart.enabled System property to false before calling SpringApplication.run(… ), as shown in the following example: 如果您想完全禁止重启功能（举个例子，它不能用于某个特殊的库），您需要在调用SpringApplication.run(… )之前设置spring.devtools.restart.enabled系统属性为fasle，如下：1234public static void main(String[] args) &#123; System.setProperty(\"spring.devtools.restart.enabled\", \"false\"); SpringApplication.run(MyApp.class, args);&#125;","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十三）：条件日志&资源排除","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十三）条件日志&资源排除","date":"2018-04-23T09:24:47.000Z","updated":"2018-04-23T08:42:41.301Z","comments":true,"path":"2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十三）条件日志&资源排除/","link":"","permalink":"http://yoursite.com/2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十三）条件日志&资源排除/","excerpt":"","text":"20.2.1 Logging changes in condition evaluation（记录条件评估中的更改）1234By default, each time your application restarts, a report showing the condition evaluation delta is logged. The report shows the changes to your application’s auto-configuration as you make changes such as adding or removing beans and setting configuration properties. 默认情况下，每次您重启您的应用，一个条件评估的增量日志将被打印在控制台。这个日志展示了您应用自动配置部分修改得内容，注入增加，删除beans或者设置配置属性。1To disable the logging of the report, set the following property: 禁用以上的日志报告，如下设置：1spring.devtools.restart.log-condition-evaluation-delta=false 20.2.2 Excluding Resources（排除资源）12345678Certain resources do not necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can be edited in-place. By default, changing resources in /META-INF/maven, /META-INF/resources, /resources, /static, /public, or /templates does not trigger a restart but does trigger a live reload. If you want to customize these exclusions, you can use the spring.devtools.restart.exclude property. For example, to exclude only /static and /public you would set the following property: 某些资源没有必要在修改得时候出发重启。举个例子，Thymeleaf模板能够就地编辑。默认情况下，改变/META-INF/maven,/META-INF/resources, /resources, /static, /public, 或者 /templates这些路径下的内容，并不需要触发重启，但会触发重载。如果您想自定义排除这些，您可以使用spring.devtools.restart.exclude 属性。举个例子，仅仅排除/static 和 /public，您可以设置以下属性：1spring.devtools.restart.exclude=static/**,public/** 12If you want to keep those defaults and add additional exclusions, use the spring.devtools.restart.additional-exclude property instead. 如果您想保留这些默认配置，并增加一些额外的排除项目，使用spring.devtools.restart.additional-exclude属性代替。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十二）：自动重启","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十二）自动重启","date":"2018-04-23T07:24:47.000Z","updated":"2018-04-23T07:33:46.815Z","comments":true,"path":"2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十二）自动重启/","link":"","permalink":"http://yoursite.com/2018/04/23/Spring BootDoc第三部分/SpringBoot翻译（二十二）自动重启/","excerpt":"","text":"20.2 Automatic Restart（自动重启）1234567Applications that use spring-boot-devtools automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a folder is monitored for changes. Note that certain resources, such as static assets and view templates, do not need to restart the application. 如果类路径下的文件被改动了，您的应用将会使用spring-boot-devtools自动重启。这将会是一个作用于您的IDE的非常有用的功能，它将会以最快的速度给您的代码修改做出反馈。默认情况下，任何类路径下的东西和文件夹中的东西都将会被监控是否被修改。注意某些资源（如静态资产和视图模板）不需要重新启动应用程序。 12345678Triggering a restartAs DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using. In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project (Build -&gt; Build Project) has the same effect. 触发重启由于DevTools监控类路径下的资源，所以只有更新类路径资源才能触发重启。如何触发类路径资源变更从而触发重启取决于您使用的IDE。在Eclipse中，保存修改文件将会触发重启，在IDEA中，构建项目会产生同样的效果。(Build -&gt; Build Project)12345As long as forking is enabled, you can also start your application by using the supported build plugins (Maven and Gradle), since DevTools needs an isolated application classloader to operate properly. By default, Gradle and Maven do that when they detect DevTools on the classpath. 只要使用分叉，您可以使用插件（Maven和Gradle）启动您的应用，因为DevTools需要隔离应用类加载器去操作属性。默认情况下，当他们在类路径中检测到DevTools时，Gradle和Maven会这样做。12345Automatic restart works very well when used with LiveReload. See the LiveReload section for details. If you use JRebel, automatic restarts are disabled in favor of dynamic class reloading. Other devtools features (such as LiveReload and property overrides) can still be used. 与LiveReload一起使用时，自动重启的效果非常好。可以查看20.3-LiveReload章节了解更多细节。如果你使用JRebel，自动重新启动被禁用，以支持动态类重装。 其他devtools功能（如LiveReload和属性覆盖）仍然可以使用。123DevTools relies on the application context’s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook (SpringApplication.setRegisterShutdownHook(false)). 重启的时候，DevTools依赖应用上下文的关闭钩子去关闭它。如果您禁用了关闭钩子(SpringApplication.setRegisterShutdownHook(false))，它将无法正常工作。1234When deciding if an entry on the classpath should trigger a restart when it changes, DevTools automatically ignores projects named spring-boot,spring-boot-devtools, spring-boot- autoconfigure, spring-boot-actuator, and spring-boot-starter. 当决策类路径下某个条目改变了是否应该触发重启的时候，DevTools自动忽略那些以spring-boot,spring-boot-devtools, spring-boot-autoconfigure, spring-boot-actuator, and spring-boot-starter命名的项目名称。1234DevTools needs to customize the ResourceLoader used by the ApplicationContext. If your application provides one already, it is going to be wrapped. Direct override of the getResource method on the ApplicationContext is not supported. DevTools需要自定义ApplicationContext中使用的资源加载器（ResourceLoader）。如果您的应用已经提供了一个，他将被代理包裹起来。不允许直接重写ApplicationContext中的getResource方法。12345678910111213Restart vs ReloadThe restart technology provided by Spring Boot works by using two classloaders. Classes that do not change (for example, those from third-party jars) are loaded into a base classloader. Classes that you are actively developing are loaded into a restart classloader. When the application is restarted, the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts”, since the base classloader is already available and populated.If you find that restarts are not quick enough for your applications or you encounter classloading issues, you could consider reloading technologies such as JRebelfrom ZeroTurnaround. These work by rewriting classes as they are loaded to make them more amenable to reloading. 重启和重载Spring Boot是通过使用2个类加载器来提供重启技术的。不被修改得类（例如第三方jar）将会被加载到一个基础的类加载器中。那些您真实要修改的类将会被加载到一个“重启”类加载器中。当应用重启的时候，“重启”类加载器将会被抛弃并重新创建一个新的“重启”类加载器。这种方法意味着应用程序重新启动通常比“冷启动”快得多，因为基类加载器已经可用并且已被填充。如果您发现重启对于您的应用程序来说不够快，或者遇到类加载问题，则可以考虑从ZeroTurnaround中重新加载技术，例如JRebel。 这些工作通过在加载类时重写类来使它们更易于重新加载。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十）：开发者工具","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十）开发者工具","date":"2018-04-21T09:24:47.000Z","updated":"2018-04-21T09:24:31.676Z","comments":true,"path":"2018/04/21/Spring BootDoc第三部分/SpringBoot翻译（二十）开发者工具/","link":"","permalink":"http://yoursite.com/2018/04/21/Spring BootDoc第三部分/SpringBoot翻译（二十）开发者工具/","excerpt":"","text":"20. Developer Tools（开发者工具）123456Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The spring-boot-devtools module can be included in any project to provide additional development-time features. To include devtools support, add the module dependency to your build, as shown in the following listings for Maven and Gradle: Spring Boot引入了额外的一些工具，让应用的开发体验变得更加愉快。spring-boot-devtools模块能够被任何项目引入提供“开发-时间”功能。如果需要支持devtools功能，增加如下模块到您的构建李，如下：Maven：1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle：123dependencies &#123; compile(\"org.springframework.boot:spring-boot-devtools\")&#125; 1234567Developer tools are automatically disabled when running a fully packaged application. If your application is launched from java -jar or if it is started from a special classloader, then it is considered a “production application”. Flagging the dependency as optional in Maven or using compileOnly in Gradle is a best practice that prevents devtools from being transitively applied to other modules that use your project. 当运行一个完整的应用jar包的时候，开发者工具集将会被自动禁用。如果您的应用是通过java -jar启动或者是通过一些特殊的类加载器启动的，它会被当做一个“产品级别的应用”。在Maven中标记devtools的依赖为可选的，在Gradle中使用compileOnly是防止devtools被传递依赖到您的其他模块的的最佳实践。1234Repackaged archives do not contain devtools by default. If you want to use a certain remote devtools feature, you need to disable the excludeDevtoolsbuild property to include it. The property is supported with both the Maven and Gradle plugins. 重新打包的档案在默认情况下不包含devtools。如果您想使用某个远程的devtools功能，您需要禁用excludeDevtoolsbuild属性去支持它。这个属性既支持Maven也支持Gradle。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（二十一）：默认属性","slug":"Spring BootDoc第三部分/SpringBoot翻译（二十一）默认属性","date":"2018-04-21T09:24:47.000Z","updated":"2018-04-21T09:36:07.492Z","comments":true,"path":"2018/04/21/Spring BootDoc第三部分/SpringBoot翻译（二十一）默认属性/","link":"","permalink":"http://yoursite.com/2018/04/21/Spring BootDoc第三部分/SpringBoot翻译（二十一）默认属性/","excerpt":"","text":"20.1 Property Defaults（默认属性）12345Several of the libraries supported by Spring Boot use caches to improve performance. For example, template engines cache compiled templates to avoid repeatedly parsing template files. Also, Spring MVC can add HTTP caching headers to responses when serving static resources. Spring Boot支持几个库使用缓存来提升性能。比如，模板引擎缓存编译模板以避免重复解析模板文件。同样的，Spring MVC在服务静态资源的时候，能将HTTP的header缓存到应答当中。12345While caching is very beneficial in production, it can be counter-productive during development, preventing you from seeing the changes you just made in your application. For this reason, spring-boot-devtools disables the caching options by default. 虽然缓存在生产中非常有益，但在开发阶段有时候会适得其反，阻止您看到您应用最新的改动。基于此，spring-boot-devtools会默认禁用缓存。123456Cache options are usually configured by settings in your application.properties file. For example, Thymeleaf offers the spring.thymeleaf.cache property. Rather than needing to set these properties manually, the spring-boot-devtools module automatically applies sensible development-time configuration. 缓存选项通常会被配置于您的application.properties文件。举个例子，Thymeleaf提供了spring.thymeleaf.cache属性。spring-boot-devtools将会自动应用合理的配置，而不是通过手动设置这些属性。12For a complete list of the properties that are applied by the devtools, see DevToolsPropertyDefaultsPostProcessor. 想要查看devtools完整的属性，请参考“https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java”","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十九）：运行您的应用","slug":"Spring BootDoc第三部分/SpringBoot翻译（十九）运行您的应用","date":"2018-04-20T12:51:47.000Z","updated":"2018-04-21T08:05:19.998Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十九）运行您的应用/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十九）运行您的应用/","excerpt":"","text":"19. Running Your Application（运行您的应用）12345One of the biggest advantages of packaging your application as a jar and using an embedded HTTP server is that you can run your application as you would any other. Debugging Spring Boot applications is also easy. You do not need any special IDE plugins or extensions. 将您的应用打包成一个jar并且使用内置的HTTP服务器有一个巨大的优势就是您可以直接运行您的应用。调试Spring Boot应用也是非常简单的。您不需要任何特殊的IDE插件或者扩展。 123This section only covers jar based packaging. If you choose to package your application as a war file, you should refer to your server and IDE documentation. 本节只讲述基于jar包打包的方式。如果你选择将您的应用打包成一个war包，您应该参考到您的服务器和IDE文档。 19.1 Running from an IDE（从一个IDE钟运行）12345You can run a Spring Boot application from your IDE as a simple Java application. However, you first need to import your project. Import steps vary depending on your IDE and build system. Most IDEs can import Maven projects directly. For example, Eclipse users can select Import… → Existing Maven Projects from the File menu. 您可以从您的IDE将Spring Boot应用作为一个简单的java应用来运行。然而，您首先需要导入您的工程。导入步骤根据您的IDE构建系统的不同而变化。大部分IDE能够直接导入Maven工程。举个例子，Eclipse用户可以选择File-Import-Existing Maven Projects菜单。1234If you cannot directly import your project into your IDE, you may be able to generate IDE metadata by using a build plugin. Maven includes plugins for Eclipse and IDEA. Gradle offers plugins for various IDEs. 如果您不能直接从IDE中导入您的工程，您可以通过构建插件生成IDE metadata。Maven包含Eclipse和IDEA的插件。Gradle为大部分IDE提供了插件1234If you accidentally run a web application twice, you see a “Port already in use” error. STS users can use the Relaunch button rather than the Run button to ensure that any existing instance is closed. 如果您偶然的运行了2次web应用，您会发现“Port already in use”端口已经被使用的报错.STS使用者，能够使用Relaunch按钮来避免这个问题，如果使用Run按钮请确认任何实例都已经处于关闭状态。 19.2 Running as a Packaged Application（作为一个大包应用运行）123If you use the Spring Boot Maven or Gradle plugins to create an executable jar, you can run your application using java -jar, as shown in the following example: 如果您使用Spring Boot Maven或者Gradle插件创建了一个可执行的jar，您可以通过java -jar命令来运行它，如下例子：1$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar 123It is also possible to run a packaged application with remote debugging support enabled. Doing so lets you attach a debugger to your packaged application, as shown in the following example: 同样可以通过远程调试模式运行一个已经打包的应用，如果远程调试开启的情况下。这样做的话您可以链接一个断点到您的已经打包的应用中，如下例子：12$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\ -jar target/myapplication-0.0.1-SNAPSHOT.jar 19.3 Using the Maven Plugin（使用Maven插件）1234The Spring Boot Maven plugin includes a run goal that can be used to quickly compile and run your application. Applications run in an exploded form, as they do in your IDE. The following example shows a typical Maven command to run a Spring Boot application: Spring Boot的Maven插件包含了一个运行目标可以快速编译和运行您的应用。应用像在您的IDE中以分解的形式运行。接下去的例子展示了一个典型的Maven命令运行Spring Boot 应用。1$ mvn spring-boot:run 12You might also want to use the MAVEN_OPTS operating system environment variable, as shown in the following example: 您也许也想使用MAVEN_OPTS操作系统环境变量，如下例子：1$ export MAVEN_OPTS=-Xmx1024m 19.4 Using the Gradle Plugin（使用Gradle插件）1234The Spring Boot Gradle plugin also includes a bootRun task that can be used to run your application in an exploded form. The bootRun task is added whenever you apply the org.springframework.boot and java plugins and is shown in the following example: Spring Boot的Gradle插件同样映入了bootRun任务，能够运用分解的方式运行您的应用。bootRun任务将会被自动引入，如果您引入了org.springframework.boot和java插件。如下例子：1$ gradle bootRun 12You might also want to use the JAVA_OPTS operating system environment variable, as shown in the following example: 您也许想使用JAVA_OPTS操作系统环境变量，如下例子：1$ export JAVA_OPTS=-Xmx1024m 19.5 Hot Swapping（热交换）1234Since Spring Boot applications are just plain Java applications, JVM hot-swapping should work out of the box. JVM hot swapping is somewhat limited with the bytecode that it can replace. For a more complete solution, JRebel can be used. 由于Spring Boot应用程序只是普通的Java应用程序，所以JVM热插拔应该可以开箱即用。JVM热插拔是在可以替代的字节码方面有所限制。需要更完整的解决方案，可以使用JRebel。 1234The spring-boot-devtools module also includes support for quick application restarts. See the Chapter 20, Developer Tools section later in this chapter and theHot swapping “How-to” for details. spring-boot-devtools模块也宝行了支持快速重启应用的功能。查看章节20，开发者工具章节接下去会讲这点，已经热插拔相关细节。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十八）：使用@SpringBootApplication注解","slug":"Spring BootDoc第三部分/SpringBoot翻译（十八）使用@SpringBootApplication注解","date":"2018-04-20T09:33:47.000Z","updated":"2018-04-20T12:25:44.827Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十八）使用@SpringBootApplication注解/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十八）使用@SpringBootApplication注解/","excerpt":"","text":"18. Using the @SpringBootApplication Annotation（使用@SpringBootApplication注解）1234Many Spring Boot developers like their apps to use auto-configuration, component scan and be able to define extra configuration on their &quot;application class&quot;. A single@SpringBootApplication annotation can be used to enable those tree features, that is: 很多Spring Boot的开发者想要他们的应用能够使用自动配置，组件扫描和定义额外的配置在他们的“主类”里。一个单独的@SpringBootApplication注解即可将这3个功能都实现，也就是： 123* @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism* @ComponentScan: enable @Component scan on the package where the application is located (see the best practices)* @Configuration: allow to register extra beans in the context or import additional configuration classes @EnableAutoConfiguration: 开启Spring Boot的自动配置机制 @ComponentSca：开启主类路径包下的组件自动扫描 @Configuration ：允许注册额外的beans到context容器中，或者导入更多的配置类1234The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration, and @ComponentScan with their default attributes, as shown in the following example: @SpringBootApplication注解等同于使用@Configuration, @EnableAutoConfiguration,和 @ComponentScan这3个注解，并且使用了他们默认的属性配置，如下例子：12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 12@SpringBootApplication also provides aliases to customize the attributes of @EnableAutoConfiguration and @ComponentScan. @SpringBootApplication注解同样提供别名去定制化@EnableAutoConfiguration和@EnableAutoConfiguration属性。1234None of these features are mandatory and you may chose to replace this single annotation by any of the features that it enables. For instance, you may not want to use component scan in your application: 这些功能都不是强制性的，您可以选择通过任何其他的开启的功能去替换这个单一的注解。例如，您可能不想使用组件扫描在你的应用中：1234567891011121314151617package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 1234In this example, Application is just like any other Spring Boot application except that @Component-annotated classes are not detected automatically and the user-defined beans are imported explicitly (see @Import). 在上面这个例子中，应用如同其他Spring Boot应用一样，除了组件注解的类不是被自动导入以及用户自定义beans被明确导入(见@Import）。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十七）：Spring Beans和依赖注入","slug":"Spring BootDoc第三部分/SpringBoot翻译（十七）Spring Beans和依赖注入","date":"2018-04-20T06:31:47.000Z","updated":"2018-04-20T08:35:32.573Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十七）Spring Beans和依赖注入/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十七）Spring Beans和依赖注入/","excerpt":"","text":"17. Spring Beans and Dependency Injection（Spring Beans和依赖注入）12345You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. For simplicity, we often find that using @ComponentScan (to find your beans) and using @Autowired (to do constructor injection) works well. 您可以自由的使用Spring框架标注的一些技术和注解来定义您的注入依赖关系。打个比方，我们经常使用@ComponentScan（去查找您的beans），用@Autowired（去做构造注入）。 12345If you structure your code as suggested above (locating your application class in a root package), you can add @ComponentScan without any arguments. All of your application components (@Component, @Service, @Repository, @Controller etc.) are automatically registered as Spring Beans. 如果您按照以上的建议构造您的代码结构（将您的主应用类放在根包下面），您可以增加@ComponentScan注解而不需要任何参数。您所有的应用组件（@Component, @Service, @Repository, @Controller 等等）都将被自动注册为Spring Beans。 12The following example shows a @Service Bean that uses constructor injection to obtain a required RiskAssessor bean: 接下去的例子展示了@Service使用构造注入去获得必要的RiskAssessor bean123456789101112131415161718package com.example.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 12If a bean has one constructor, you can omit the @Autowired, as shown in the following example: 如果一个bean有一个构造函数，您可以省略@Autowired注解，如下例子：123456789101112@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 123Notice how using constructor injection lets the riskAssessor field be marked as final, indicating that it cannot be subsequently changed. 注意介绍如何使用构造注入使riskAssessor字段被标记为final，表明它不可以随后改变。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十六）：自动配置","slug":"Spring BootDoc第三部分/SpringBoot翻译（十六）自动配置","date":"2018-04-20T05:31:47.000Z","updated":"2018-04-20T08:35:23.834Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十六）自动配置/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十六）自动配置/","excerpt":"","text":"16. Auto-configuration（自动配置）1Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database. Spring Boot 自动配置将根据您增加的jar包依赖关系尝试全自动的配置您的Spring应用。举个例子，如果HSQLDB在您的类路径下，而您未配置任何数据库连接beans，Spring将会自动配置一个基于内存的数据库。 123You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes. 您需要通过增加@EnableAutoConfiguration或者@SpringBootApplication注解到您的@Configuration配置类，以此来加入自动配置的功能。 1234You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only. 您应该只添加@SpringBootApplication或者@EnableAutoConfiguration中的一个注解。我们一般建议您将一个或另一个添加到您的主@Configuration类。 16.1 Gradually Replacing Auto-configuration（逐渐替换自动配置）1234Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support backs away. 自动配置是非侵入式的。 在任何时候，您都可以开始定义自己的配置以替换自动配置的特定部分。例如，如果您添加自己的DataSource bean，则默认的嵌入式数据库支持会被取消。1234If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console. 如果您需要了解当前正在应用的自动配置以及为什么被使用，采用–debug开关启动您的应用程序。这样做可以启用debug断点日志作为主日志输出，记录各种条件分支报告到控制台。 16.2 Disabling Specific Auto-configuration Classes（禁用特定的自动配置类）1234If you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them, as shown in the following example: 如果您发现一些特殊的自动配置类，您并不想他们生效。您可以在@EnableAutoConfiguration注解中使用排除标签去禁用他们，如下例子：12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 1234If the class is not on the classpath, you can use the excludeName attribute of the annotation and specify the fully qualified name instead. Finally, you can also control the list of auto-configuration classes to exclude by using the spring.autoconfigure.exclude property. 如果该类不在类路径下，您可以使用该注解的excludeName属性去定义全路径名称来替代。最后，您可以通过使用spring.autoconfigure.exclude控制自动配置的类的列表。 12You can define exclusions both at the annotation level and by using the property. 你既可以在注解中定义exclusions，也可以在property属性中定义。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十五）：配置类","slug":"Spring BootDoc第三部分/SpringBoot翻译（十五）配置类","date":"2018-04-20T04:31:47.000Z","updated":"2018-04-20T03:42:13.300Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十五）配置类/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十五）配置类/","excerpt":"","text":"15. Configuration Classes（配置类）12345Spring Boot favors Java-based configuration. Although it is possible to use SpringApplication with XML sources, we generally recommend that your primary source be a single @Configuration class. Usually the class that defines the main method is a good candidate as the primary @Configuration. Spring Boot偏向于使用Java-base的配置方式。尽管他也能够支持使用SpringApplication配合XML，我们通常还是强烈建议您使用单个的@Configuration注解类做配置类。通常定义main方法的类用来作为一个主配置类是一个很好的选择。 15.1 Importing Additional Configuration Classes（导入其他配置类）12345You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes. 您并不需要将您所有的配置放在一个@Configuration注解的类中。@Import注解可以用来导入额外的注解类。另外，您可以使用@ComponentScan注解去制动选择所有的Spring组件。包括@Configuration注解的配置类。 123We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, com.example.project). 我们建议您遵循Java推荐的软件包命名约定并使用反向域名（例如，com.example.project）。 15.2 Importing XML Configuration（导入XML配置）123If you absolutely must use XML based configuration, we recommend that you still start with a @Configuration class. You can then use an @ImportResourceannotation to load XML configuration files. 如果您是在要使用基于XML的配置，我们建议您还是从一个@Configuration注解的类开始。您可以在其中使用@ImportResourceannotation注解去加载XML配置文件。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十四）：组织你的代码","slug":"Spring BootDoc第三部分/SpringBoot翻译（十四）组织你的代码","date":"2018-04-20T02:31:47.000Z","updated":"2018-04-20T03:27:37.560Z","comments":true,"path":"2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十四）组织你的代码/","link":"","permalink":"http://yoursite.com/2018/04/20/Spring BootDoc第三部分/SpringBoot翻译（十四）组织你的代码/","excerpt":"","text":"14. Structuring Your Code（组织您的代码）12Spring Boot does not require any specific code layout to work. However, there are some best practices that help. Spring Boot不需要任何特殊的代码框架就能运行。然而，有一些最佳实践可以给予您更多的帮助。 14.1 Using the “default” Package(使用默认包）123456When a class does not include a package declaration, it is considered to be in the “default package”. The use of the “default package” is generally discouraged and should be avoided. It can cause particular problems for Spring Boot applications that use the @ComponentScan, @EntityScan, or @SpringBootApplicationannotations, since every class from every jar is read. 当一个类不包含包声明时，它是被认为是在“默认包”中。 使用“默认包”通常是不鼓励的，应该是避免。 它可能会导致Spring Boot的特殊问题，诸如在使用@ComponentScan，@EntityScan或@SpringBootApplicationannotations的应用程序，因为每个包里的每个类都会被读取。 123We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, com.example.project). 我们建议您遵循Java推荐的软件包命名约定并使用反向域名（例如，com.example.project）。 14.2 Locating the Main Application Class（定位主应用类）1234567We generally recommend that you locate your main application class in a root package above other classes .The @SpringBootApplication annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the @SpringBootApplication annotated class is used to search for @Entity items. Using a root package also allows component scan to apply only on your project. 我们通常推荐您将主应用类放到高于其他的类的根目录。@SpringBootApplication注解一般用于您的主应用类上，它隐含地为某些项目定义了一个基础“搜索包”。举个例子，如果你正在写一个JPA应用程序，@SpringBootApplication注释类所在的包将会用于搜索@Entity注解。 使用根包也允许组件扫描仅适用于您的项目。1234If you don’t want to use @SpringBootApplication, the @EnableAutoConfiguration and @ComponentScan annotations that it imports defines that behaviour so you can also use that instead. 如果您不想使用注解@SpringBootApplication，注解@EnableAutoConfiguration 和 @ComponentScan组合使用可以起到替代它的作用。1The following listing shows a typical layout: 以下的列表显示了一个典型的类和包结构布局：12345678910111213141516com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 12The Application.java file would declare the main method, along with the basic @SpringBootApplication, as follows: Application.java文件将定义main方法，已经基本的@SpringBootApplication如下：12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十三）：Starters","slug":"Spring BootDoc第三部分/SpringBoot翻译（十三）Starters","date":"2018-04-19T05:31:47.000Z","updated":"2018-04-20T03:27:25.688Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十三）Starters/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十三）Starters/","excerpt":"","text":"13.5 Starters1234567Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa dependency in your project. “Starters”是一组可以导入到您的应用中的方便可用的依赖描述符。您将可以在不需要通过示例代码搜索拷贝-粘贴的情况下一站式获得所有关于Spring相关联的技术依赖。举个例子，如果您选择使用Spring和JPA作为数据库接入组件，导入spring-boot-starter-data-jpa依赖进您的工程即可。 123The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies. 这些“Starters”包含很多您需要的让项目快速启动的依赖，并保持一致，支持一组受管控的传递依赖。 123456789101112131415What’s in a nameAll official starters follow a similar naming pattern; spring-boot-starter-*, where * is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or STS plugin installed, you can press ctrl-space in the POM editor and type “spring-boot-starter” for a complete list.As explained in the “Creating Your Own Starter” section, third party starters should not start with spring-boot, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter. 名字中包含了什么？所有的官方“starters”遵循一个相同的命名规范；spring-boot-starter-,““是代表特定类型的应用。这种命名结构能够在您需要寻找一个“starter”的时候提供有利的帮助。在许多集成了Maven的IDE中，您都可以按名称搜索依赖项。比如，通过安装适当的Eclipse或STS插件，你可以在POM编辑器中按ctrl-space并键入“spring-boot-starter”获取完整列表。如上所述，“创建您自己的Starter”，第三方“starters”不应该使用spring-boot作为开头，因为他是为官方Spring Boot保留的。然而，一个第三方的starter一般以工程名开始。举个例子，一个第三方的starter工程名为“thirdpartyproject”，可以以“thirdpartyproject-spring-boot-starter”来命名。12The following application starters are provided by Spring Boot under the org.springframework.boot group: 如下应用的starters被Spring Boot提供，在 org.springframework.boot group下 名字 描述 spring-boot-starter 核心starter, 包括自动配置支持, 日志和YMAL支持。 spring-boot-starter-activemq Starter用于JMS消息，使用Apache的ActiveMQ spring-boot-starter-amqp Starter用于使用Spring AMQP 和Rabbit MQ spring-boot-starter-aop Starter用于在Spring AOP 和 AspectJ下的面相切面编程 spring-boot-starter-artemis Starter用于JMS消息 ，应用于 Apache Artemis spring-boot-starter-batch Starter 用于使用Spring Batch spring-boot-starter-cache Starter用于使用Spring Framework下的缓存支持 spring-boot-starter-cloud-connectors Starter用于Spring Cloud连接，它简化了连接到Cloud Foundry和Heroku等云平台的服务 spring-boot-starter-data-cassandra Starter用于使用Cassandra分布式数据库和Spring Data Cassandra spring-boot-starter-data-cassandra-reactive Starter用于使用Cassandra分布式数据库和Spring Data Cassandra Reactive spring-boot-starter-data-couchbase Starter用于Couchbase面向文档的数据库和Spring Data Couchbase spring-boot-starter-data-couchbase-reactive Starter用于使用Couchbase面向文档的数据库和Spring Data Couchbase Reactive spring-boot-starter-data-elasticsearch Starter用于使用Elasticsearch 查找分析引擎 和 Spring Data Elasticsearch spring-boot-starter-data-jpa Starter用于Spring Data JPA和Hibernate spring-boot-starter-data-ldap Starter用于Spring Data LDAP spring-boot-starter-data-mongodb Starter用于MongoDB 基于文档的数据库和Spring Data MongoDB spring-boot-starter-data-mongodb-reactive Starter用于使用MongoDB面向文档的数据库和Spring Data MongoDB Reactive spring-boot-starter-data-neo4j Starter用于使用Neo4j图形数据库和Spring Data Neo4jPom spring-boot-starter-data-redis Starter用于在Spring Data Redis和Lettuce客户端中使用Redis键值数据存储 spring-boot-starter-data-redis-reactive Starter用于使用Redis键值数据存储以及Spring Data Redis反应器和Lettuce客户端 spring-boot-starter-data-rest Starter用于使用Spring Data REST将Spring Data存储库暴露于REST spring-boot-starter-data-solr Starter用于在Spring Data Solr中使用Apache Solr搜索平台 spring-boot-starter-freemarker Starter用于基于FreeMarker View的MVC web应用 spring-boot-starter-groovy-templates Starter用于建设基于Groovy模板的MVC web应用 spring-boot-starter-hateoas Starter用于使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序 spring-boot-starter-integration Starter用于使用Spring Integration spring-boot-starter-jdbc Starter用于使用JDBC和HikariCP连接池的入门者 spring-boot-starter-jersey Starter用于建设基于JAX-RS and Jersey的RESTful web应用Spring-Boot-Starter-Web的另一种选择 spring-boot-starter-jooq Starter用于JPPQ数据连接框架.spring-boot-starter-data-jpa 和 spring-boot-starter-jdbc的替代者 spring-boot-starter-json Starter用于读写json spring-boot-starter-jta-atomikos Starter用于使用Atomikos的JTA事务 spring-boot-starter-jta-bitronix Starter用于使用Bitronix的JTA事务 spring-boot-starter-jta-narayana Starter用于使用Narayana的JTA事务 spring-boot-starter-mail Starter用于使用Java Mail 和 Spring Framework的email发送支持 spring-boot-starter-mustache Starter用于建设基于Mustache views的web应用 spring-boot-starter-quartz Starter用于Quartz scheduler定时器任务 spring-boot-starter-security Starter用于使用Spring Security spring-boot-starter-test Starter用于测试Spring Boot应用包含JUnit, Hamcrest 和 Mockito spring-boot-starter-thymeleaf Starter用于基于thymeleaf视图的的MVC应用建设 spring-boot-starter-validation Starter用于使用Java Bean的检验框架，基于hibernate的校验器 spring-boot-starter-web Starter用于构建web应用, 包含RESTful, 应用基于使用 Spring MVC. 使用Tomcat作为默认的容器 spring-boot-starter-web-services Starter用于使用Spring Web Services spring-boot-starter-webflux Starter用于使用WebFlux Spring Framework’s Reactive Web 支持 spring-boot-starter-websocket Starter用于构建基于Spring Framwork的websocket支持 12In addition to the application starters, the following starters can be used to add production ready features: 除了应用级别的starters以外，下面的这个starter具备产品级功能应用。1Table 13.2. Spring Boot production starters Spring Boot的产品级starters名字 | 描述——— | ————-spring-boot-starter-actuator|Starter用于Spring Boot 的 Actuator，它是用于提供产品级别的应用管理和监控功能 1Finally, Spring Boot also includes the following starters that can be used if you want to exclude or swap specific technical facets: 最后，Spring Boot还提供了如下的starters用于帮助您排除或者替代的starters 1Table 13.3. Spring Boot technical starters Spring Boot技术starters名字 | 描述——— | ————-spring-boot-starter-jetty|Starter用于使用基于servlet技术的内置jetty容器。 可以用于替代spring-boot-starter-tomcatspring-boot-starter-log4j2|Starter用于基于log4j2的日志处理。可以替代现有的spring-boot-starter-loggingspring-boot-starter-logging|Starter用于基于Logback的日志处理. 也是默认的日志处理器。spring-boot-starter-reactor-netty|Starter用于Reactor Netty作为内置容器的响应式HTTP 服务器.spring-boot-starter-tomcat|Starter用于内置的Tomcat容器，如果使用spring-boot-starter-web依赖的话，会将此作为默认以来spring-boot-starter-undertow|Starter用于基于undertow的内置容器，spring-boot-starter-tomcat的替代者。 12For a list of additional community contributed starters, see the README file in the spring-boot-starters module on GitHub. 如果想要获得社区贡献的更多的starters，请阅读GitHub上spring-boot-starters模块的README文件。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十二）：Gradle&Ant","slug":"Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant","date":"2018-04-19T04:31:47.000Z","updated":"2018-04-20T03:25:09.125Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant/","excerpt":"","text":"13.3 Gradle12To learn about using Spring Boot with Gradle, please refer to the documentation for Spring Boot’s Gradle plugin: 学习在Spring Boot中使用Gradle请转到如下Spring Boot的Gradle插件关联文档中：（https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/gradle-plugin/reference/html/） 13.4 Ant12345It is possible to build a Spring Boot project using Apache Ant+Ivy. The spring-boot-antlib “AntLib” module is also available to help Ant create executable jars.To declare dependencies, a typical ivy.xml file looks something like the following example: 您同样可以使用Apache的Ant配合Ivy去构建Spring Boot工程。spring-boot-antlib 的“AntLib”模块同样可以帮助Ant创建可执行的jars包。声明依赖，一个典型的ivy.xml文件如下：1234567891011&lt;ivy-module version=\"2.0\"&gt; &lt;info organisation=\"org.springframework.boot\" module=\"spring-boot-sample-ant\" /&gt; &lt;configurations&gt; &lt;conf name=\"compile\" description=\"everything needed to compile this module\" /&gt; &lt;conf name=\"runtime\" extends=\"compile\" description=\"everything needed to run this module\" /&gt; &lt;/configurations&gt; &lt;dependencies&gt; &lt;dependency org=\"org.springframework.boot\" name=\"spring-boot-starter\" rev=\"$&#123;spring-boot.version&#125;\" conf=\"compile\" /&gt; &lt;/dependencies&gt;&lt;/ivy-module&gt; 1A typical build.xml looks like the following example: 一个典型的build.xml如下： 123456789101112131415161718192021222324252627282930313233&lt;project xmlns:ivy=\"antlib:org.apache.ivy.ant\" xmlns:spring-boot=\"antlib:org.springframework.boot.ant\" name=\"myapp\" default=\"build\"&gt; &lt;property name=\"spring-boot.version\" value=\"2.1.0.BUILD-SNAPSHOT\" /&gt; &lt;target name=\"resolve\" description=\"--&gt; retrieve dependencies with ivy\"&gt; &lt;ivy:retrieve pattern=\"lib/[conf]/[artifact]-[type]-[revision].[ext]\" /&gt; &lt;/target&gt; &lt;target name=\"classpaths\" depends=\"resolve\"&gt; &lt;path id=\"compile.classpath\"&gt; &lt;fileset dir=\"lib/compile\" includes=\"*.jar\" /&gt; &lt;/path&gt; &lt;/target&gt; &lt;target name=\"init\" depends=\"classpaths\"&gt; &lt;mkdir dir=\"build/classes\" /&gt; &lt;/target&gt; &lt;target name=\"compile\" depends=\"init\" description=\"compile\"&gt; &lt;javac srcdir=\"src/main/java\" destdir=\"build/classes\" classpathref=\"compile.classpath\" /&gt; &lt;/target&gt; &lt;target name=\"build\" depends=\"compile\"&gt; &lt;spring-boot:exejar destfile=\"build/myapp.jar\" classes=\"build/classes\"&gt; &lt;spring-boot:lib&gt; &lt;fileset dir=\"lib/runtime\" /&gt; &lt;/spring-boot:lib&gt; &lt;/spring-boot:exejar&gt; &lt;/target&gt;&lt;/project&gt; 123If you do not want to use the spring-boot-antlib module, see the Section 86.9, “Build an Executable Archive from Ant without Using spring-boot-antlib” “How-to” . 如果您不想使用spring-boot-antlib模块，请直接看章节86.9“Build an Executable Archive from Ant without Using spring-boot-antlib”","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十一）：使用Spring Boot&Maven","slug":"Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot","date":"2018-04-19T03:31:47.000Z","updated":"2018-04-20T03:24:57.121Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot/","excerpt":"","text":"Part III. Using Spring Boot（使用Spring Boot）1234567This section goes into more detail about how you should use Spring Boot. It covers topics such as build systems, auto-configuration, and how to run your applications. We also cover some Spring Boot best practices. Although there is nothing particularly special about Spring Boot (it is just another library that you can consume), there are a few recommendations that, when followed, make your development process a little easier. 本部分介绍了更多的关于您如何使用Spring Boot的细节。它涵盖了构建系统，自动配置，如何运行您的应用等主题。我们同样涉及了Spring Boot的最佳实践。尽管Spring Boot并没有什么非常特别的东西（它仅仅是您可消费的另一个库而已），接下去，有一些建议，可以使您的部署进程变得更加简单。 13. Build Systems（构建系统）123456It is strongly recommended that you choose a build system that supports dependency management and that can consume artifacts published to the “Maven Central” repository. We would recommend that you choose Maven or Gradle. It is possible to get Spring Boot to work with other build systems (Ant, for example), but they are not particularly well supported. 我们强烈推荐您选择一款构建系统支持依赖管理的，并且能够发布到“Maven Central”库。我们推荐您选择Maven或者Gradle。当然，Spring Boot也同样能够作用于诸如Ant等构建工具，但是对于他们的支持并不是全面的。 13.1 Dependency Management（依赖管理）123456Each release of Spring Boot provides a curated list of dependencies that it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration, as Spring Boot manages that for you. When you upgrade Spring Boot itself, these dependencies are upgraded as well in a consistent way. Spring Boot的每个发行版都提供了一个它支持的依赖关系的策划列表。基于实践，在您的构建配置中您不需要为任何依赖提供一个版本。因为Spring Boot为您管理这些版本。当您升级Spring Boot本身的时候，这些依赖版本会以一致的方式很好的自动升级。 12You can still specify a version and override Spring Boot’s recommendations if you need to do so. 如果您愿意的话，您依然可以指定一个版本覆盖Spring Boot建议的版本。 1234The curated list contains all the spring modules that you can use with Spring Boot as well as a refined list of third party libraries. The list is available as a standard Bills of Materials (spring-boot- dependencies) that can be used with both Maven and Gradle. 这个策划列表包含了所有的您可以配合Spring Boot 使用的spring模块和一个精简的第三方库。这个列表可以作为一个标准的材料清单（spring-boot-dependencies）用于Maven或者Gradle。 12Each release of Spring Boot is associated with a base version of the Spring Framework. We highly recommend that you not specify its version 每一个发布的Spring Boot版本会关联Spring的一个基础版本。我们高度推荐您不要自定义它的版本。 13.2 Maven123Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults. The parent project provides the following features: Maven用户可以继承spring-boot-starter-parent 工程去获得合理的默认值。该父工程提供了如下的功能： 123456789• Java 1.8 as the default compiler level.• UTF-8 source encoding.• A Dependency Management section, inherited from the spring-boot-dependencies pom, that manages the versions of common dependencies. This dependency management lets you omit &lt;version&gt; tags for those dependencies when used in your own pom.• Sensible resource filtering.• Sensible plugin configuration (exec plugin, Git commit ID, and shade).• Sensible resource filtering for application.properties and application.yml including profile-specific files (for example, application-dev.properties and application-dev.yml) java 1.8作为默认的编译等级 UTF-8作为源编码字符集 依赖管理部分，继承于spring-boot-dependencies pom管理基础依赖版本。这种依赖管理能够让您在您的pom中忽略标签。 恰到好处的资源过滤 恰如其分的插件配置(exec plugin, Git commit ID, and shade) 通过profile—specific为application.properties和application.yml做恰当的资源文件过滤（例如application-dev.properties 和 application-dev.yml） 1234Note that, since the application.properties and application.yml files accept Spring style placeholders ($&#123;… &#125;), the Maven filtering is changed to use @..@placeholders. (You can override that by setting a Maven property called resource.delimiter.) 注意，因为application.properties 和 application.yml文件接收Spring风格的占位符（${… })，Maven过滤器变成使用@..@占位符。（您可以通过resource.delimiter文件设置Maven的属性覆盖maven的占位符。 13.2.1 Inheriting the Starter Parent（继承父Starter）12To configure your project to inherit from the spring-boot-starter-parent, set the parent as follows: 配置您的工程去继承spring-boot-starter-parent，设置父pom如下： 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 123You should need to specify only the Spring Boot version number on this dependency. If you import additional starters, you can safely omit the version number. 你仅仅只需要再依赖中定义Spring Boot的版本号。如果您想导入额外的starters，您可以安全的忽略版本号。1234With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to upgrade to another Spring Data release train, you would add the following to your pom.xml: 用那个设置，您依然可以通过复写属性覆盖个人的依赖，例如，升级到另一个Spring Data的升级版，您可以增加以下配置到您的pom.xml中：123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 1Check the spring-boot-dependencies pom for a list of supported properties. 检查spring-boot-dependencies pom（https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-dependencies/pom.xml）以获取支持的属性列表 13.2.2 Using Spring Boot without the Parent POM（不使用父POM）123Not everyone likes inheriting from the spring-boot-starter-parent POM. You may have your own corporate standard parent that you need to use or you may prefer to explicitly declare all your Maven configuration. 并不是每个人都喜欢用继承于spring-boot-starter-parent POM的方式。您可能需要使用您自己的团队标准的父POM，又或者您更愿意明确声明您所有的Maven配置 123If you do not want to use the spring-boot-starter-parent, you can still keep the benefit of the dependency management (but not the plugin management) by using a scope=import dependency, as follows: 如果您不愿使用spring-boot-starter-parent，您仍然可以通过使用scope=import依赖来保留依赖管理的价值，如下： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 123456The preceding sample setup does not let you override individual dependencies by using a property, as explained above. To achieve the same result, you need to add an entry in the dependencyManagement of your project before the spring-boot-dependencies entry. For instance, to upgrade to another Spring Data release train, you could add the following element to your pom.xml: 如上所述，上述示例设置不会让您通过使用属性覆盖个人依赖关系。为了达到同样目标，您需要在dependencyManagement中的spring-boot-dependencies前使用一个节点。举个例子，升级另一个Spring Data 发行版本，您可以增加如下的元素到您的pom.xml中12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 12In the preceding example, we specify a BOM, but any dependency type can be overridden in the same way. 在之前的例子中，我们定义了一个清单，但是任何的依赖类型都能够以这种方式进行覆盖。 13.2.3 Using the Spring Boot Maven Plugin123Spring Boot includes a Maven plugin that can package the project as an executable jar. Add the plugin to your &lt;plugins&gt; section if you want to use it, as shown in the following example: Spring Boot引入了一个Maven的插件，可以打包工程，使之成为一个可执行jar。如果您想使用它的话，增加该插件到部分。如下展示的示例： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 123If you use the Spring Boot starter parent pom, you need to add only the plugin. There is no need to configure it unless you want to change the settings defined in the parent. 如果您使用父POM的方式，您仅仅只需要增加这个插件就可以了。不需要配置它，除非您想改变父POM定义的配置。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十）：创建一个可执行jar包","slug":"Spring BootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包","date":"2018-04-18T08:59:47.000Z","updated":"2018-04-20T03:29:48.554Z","comments":true,"path":"2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包/","link":"","permalink":"http://yoursite.com/2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包/","excerpt":"","text":"11.5 Creating an Executable Jar（运行示例）12345We finish our example by creating a completely self-contained executable jar file that we could run in production. Executable jars (sometimes called “fat jars”) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run. 我们通过创建一个完全独立的可执行JAR文件来完成我们的示例，我们可以在生产中运行它。可执行jars（有时候也叫做“重量级jars”）是包含了您自身编译的类和其所依赖的所有jar包的一个整合归档包。 Executable jars and Java1234567891011Java does not provide a standard way to load nested jar files (jar files that are themselves contained within a jar). This can be problematic if you are looking to distribute a self-contained application. To solve this problem, many developers use “uber” jars. An uber jar packages all the classes from all the application’s dependencies into a single archive. The problem with this approach is that it becomes hard to see which libraries are in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars.Spring Boot takes a different approach and lets you actually nest jars directly. Java并不提供一个标准的方式去嵌套jar文件（jar文件本身又包含另一个jar）。这将成为一个阻碍，如果您打算发布一个独立运行的jar应用。为了解决这个问题，很多开发者使用“uber”包。一个“uber”包根据应用的依赖关系打包了所有的类到一个单独的归档中。采用这种途径打包之后产生的另一个问题是，您无法知道在您的应用中有哪些库。这还产生一个新的问题就是一些同名的文件会被应用到多个不同的（但包含不同的内容)jars当中。Spring Boot 采用了一个不同的方式让您可以直接嵌套jars包。123To create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependenciessection: 创建一个可执行jar，我们需要增减一个spring-boot-maven-plugin到pom文件中。可以这样做，插入下面的配置行到依赖关系部分下面。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1234The spring-boot-starter-parent POM includes &lt;executions&gt; configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details. spring-boot-starter-parent的pom文件包含配置，可以绑定执行repackage对象。如果您不使用父POM，您需要自己声明这个配置。您可以在plugin的文档中得到更为详细的信息（https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/maven-plugin/usage.html） 1Save your pom.xml and run mvn package from the command line, as follows: 保存您的pom.xml,在命令行中运行mvn package，如下：123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.1.0.BUILD-SNAPSHOT:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 1234If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows: 如果您在target目录下查看，你将会看到myproject-0.0.1-SNAPSHOT.jar。这个文件大概10M左右的样子。如果您想一窥内部构造，您可以使用 jar tvf命令，如下： 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 1234You should also see a much smaller file named myproject-0.0.1- SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot. To run that application, use the java -jar command, as follows: 您应该同样的会看到一个比较小的名称为myproject-0.0.1-SNAPSHOT.jar.original的文件在target目录下。这是maven在Spring Boot进行repackaged之前创建的原版的jar文件。运行这个应用，使用java -jar命令，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.0.BUILD-SNAPSHOT)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 1As before, to exit the application, press ctrl-c. 跟之前一样，如果想退出应用，按ctrl+c 12. What to Read Next（接下去阅读什么）12345Hopefully, this section provided some of the Spring Boot basics and got you on your way to writing your own applications. If you are a task-oriented type of developer, you might want to jump over to spring.io and check out some of the getting started guides that solve specific “How do I do that with Spring?” problems. We also have Spring Boot-specific “How-to” reference documentation. 希望，本节提供了一些Spring Boot的基础知识和能帮助您以您自己的方式编写自己的应用程序。如果您是一个面向任务的开发人员类型，您可能想跳到spring.io并查看一些入门指南解决具体的“我怎样用Spring做这件事”的问题。 我们也具有特定于Spring Boot的“操作方法”参考文档。 123The Spring Boot repository also has a bunch of samples you can run. The samples are independent of the rest of the code (that is, you do not need to build the rest to run or use the samples). Spring Boot存储库还有一堆你可以运行的样本。样本与代码的其余部分无关（即，您无需要构建其余的代码去运行或使用样本）123Otherwise, the next logical step is to read Part III, “Using Spring Boot”. If you are really impatient, you could also jump ahead and read about Spring Boot features. 除此之外，下一个合乎逻辑的步骤是阅读第三部分，“使用Spring Boot”。如果您真的不耐烦，您可以跳过此章节，阅读Spring Boot的功能部分。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（九）：运行示例","slug":"Spring BootDoc第二部分/SpringBoot翻译（九）运行示例","date":"2018-04-18T07:32:47.000Z","updated":"2018-04-20T03:29:35.562Z","comments":true,"path":"2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（九）运行示例/","link":"","permalink":"http://yoursite.com/2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（九）运行示例/","excerpt":"","text":"11.4 Running the Example（运行示例）12345At this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following: 此时，您的应用程序应该可以工作了。由于使用了spring-boot-starter-parent POM，所以您有一个可用的运行目标，可以用来启动应用程序。在工程的根木兰路下输入mvn spring-boot:run启动应用。您应该看到类似于以下的输出：12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.0.BUILD-SNAPSHOT)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 12If you open a web browser to localhost:8080, you should see the following output: 如果您打开一个web浏览器输入localhost:8080，您将会看到如下的输出： 1Hello World! 1To gracefully exit the application, press ctrl-c. 优雅退出请按ctrl+c","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（八）：开始写代码","slug":"Spring BootDoc第二部分/SpringBoot翻译（八）开始写代码","date":"2018-04-18T03:56:47.000Z","updated":"2018-04-20T03:29:21.243Z","comments":true,"path":"2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（八）开始写代码/","link":"","permalink":"http://yoursite.com/2018/04/18/Spring BootDoc第二部分/SpringBoot翻译（八）开始写代码/","excerpt":"","text":"11.3 Writing the Code（开始写代码）1234To finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code: 为了完成我们的应用，我们需要创建一个单独的java文件夹。默认情况下，maven从src/main/java中编译源码，因此，您需要创建一个类似于此的文件结构目录并加入您的示例类src/main/java/Example.java并包含以下代码 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 12Although there is not much code here, quite a lot is going on. We step through the important parts in the next few sections. 尽管并没有多少代码，但很多事情静静的发生了。我们将在接下来的章节，带您一步一步解开它的神秘面纱。 11.3.1 The @RestController and @RequestMapping Annotations12345The first annotation on our Example class is @RestController. This is known as a stereotype annotation. It provides hints for people reading the code and for Spring that the class plays a specific role. In this case, our class is a web @Controller, so Spring considers it when handling incoming web requests. 在我们Example类的第一个注解是@RestController。这被认为是一个刻板的注解。它为大家提供了直接的提示，并且告诉Spring容器，被注解的这个类扮演了一个特殊的角色。在这个例子李，我们的类是一个web类型的@Controller，所以Spring会注意到这点，并将web请求交给该类来处理。 1234The @RequestMapping annotation provides “routing” information. It tells Spring that any HTTP request with the / path should be mapped to the home method. The@RestController annotation tells Spring to render the resulting string directly back to the caller. @RequestMapping注解提供了“路由”信息。它告诉Sring，任何的HTTP以/结尾的请求需要映射到home方法上。@RestController注解告诉Spring将结果字符串直接返回给调用方。 123The @RestController and @RequestMapping annotations are Spring MVC annotations. (They are not specific to Spring Boot.) See the MVC sectionin the Spring Reference Documentation for more details. @RestController和@RequestMapping这两个注解是Spring MVC的注解，并非专门为Spring Boot提供的。您可以到Spring官方文档的MVC相关的章节去获取更多的信息。 11.3.2 The @EnableAutoConfiguration Annotation123456The second class-level annotation is @EnableAutoConfiguration. This annotation tells Spring Boot to “guess” how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. 第二个类级别注解@EnableAutoConfiguration，这个注解告诉Spring Boot 去“猜”您是想怎样配置Spring，基于您已经添加的jar包依赖。因为spring-boot-starter-web包含了Tomcat和Spring MVC，auto-configuration自动配置会推断您想开发一个web应用并据此设定Spring相关配置。12345Starters and Auto-ConfigurationAuto-configuration is designed to work well with “Starters”, but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters. Spring Boot still does its best to auto-configure your application. “Starters”和“Auto-Configuration”自动配置的设计是为了更好的配合“Starters”运作，但是两个概念并不直接相关。您可以自由的挑选不在“Starters”中的jar依赖。Spring Boot依然尽最大努力为您的应用做自动配置。 11.3.3 The “main” Method （”main“方法）123456789The final part of our application is the main method. This is just a standard method that follows the Java convention for an application entry point. Our main method delegates to Spring Boot’s SpringApplication class by calling run. SpringApplication bootstraps our application, starting Spring, which, in turn, starts the auto-configured Tomcat web server. We need to pass Example.class as an argument to the run method to tell SpringApplication which is the primary Spring component. The args array is also passed through to expose any command-line arguments. 本节的最后一部分介绍我们应用的”main“方法。这只是遵循Java约定的标准方法应用程序入口点。我们的main方法会调用给Spring Boot的SpringApplication类的run方法。SpringApplication引导我们的应用程序，从Spring开始，启动自动配置的Tomcat Web服务器。我们需要将Example.class作为run方法的一个参数，去通知SpringApplication，这是Spring的主要组件。该参数数组同样可以通过任何暴露的命令行参数进行传递。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（七）：增加类路径依赖","slug":"Spring BootDoc第二部分/SpringBoot翻译（七）增加类路径依赖","date":"2018-04-17T12:35:47.000Z","updated":"2018-04-20T03:29:03.983Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（七）增加类路径依赖/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（七）增加类路径依赖/","excerpt":"","text":"11.2 Adding Classpath Dependencies（增加类路径依赖）123456Spring Boot provides a number of “Starters” that let you add jars to your classpath. Our sample application has already used spring-boot-starter-parent in the parent section of the POM. The spring-boot-starter-parent is a special starter that provides useful Maven defaults. It also provides a dependency-management section so that you can omit version tags for “blessed” dependencies. Spring Boot 提供了一些“Starters”用于您增加一些jars包到您的类路径下。我们的示例应用已经使用了spring-boot-starter-parent在上一节的POM文件中。spring-boot-starter-parent是一个提供了非常有用的Maven默认的特殊的starter。它同样提供了一个dependency-management部分，以便于您可以为一些“幸福”依赖忽略版本标签。 12345Other “Starters” provide dependencies that you are likely to need when developing a specific type of application. Since we are developing a web application, we add a spring-boot-starter-web dependency. Before that, we can look at what we currently have by running the following command: 其他“Starters”提供了一些依赖，以便于您可以在开发一些特殊模式的应用，如果我们需要部署一个web应用，我们需要增加 spring-boot-starter-web的依赖。在此之前，我们可以使用以下命令寻找我们目前已有的依赖：123$ mvn dependency:tree[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT 12345The mvn dependency:tree command prints a tree representation of your project dependencies. You can see that spring-boot-starter-parent provides no dependencies by itself. To add the necessary dependencies, edit your pom.xml and add the spring-boot-starter-web dependency immediately below the parent section: mvn dependency:tree命令会将您的应用依赖以树形展示。您可以发现spring-boot-starter-parent本身并不提供任何依赖。如果需要增加必要的依赖，更改您的pom.xml，增加spring-boot-starter-web依赖紧接在父节点下面：123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123If you run mvn dependency:tree again, you see that there are now a number of additional dependencies, including the Tomcat web server and Spring Boot itself. 如果您再次运行mvn dependency:tree，您将会看到一系列的新增的依赖，包括tomcat服务器和Spring Boot本身","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（六）：创建POM文件","slug":"Spring BootDoc第二部分/SpringBoot翻译（六）创建POM文件","date":"2018-04-17T12:15:47.000Z","updated":"2018-04-20T03:28:53.628Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（六）创建POM文件/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（六）创建POM文件/","excerpt":"","text":"11.1 Creating the POM(创建POM文件)123We need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following: 我们需要以创建一个pom.xml文件开始。pom.xml是用于构建项目的配方。 打开您最喜欢的文本编辑器并添加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 123The preceding listing should give you a working build. You can test it by running mvn package (for now, you can ignore the “jar will be empty - no content was marked for inclusion!” warning). 上面的列表应该已经给了您一个可工作的构建。您可以使用mvn package来运行测试它（现在，你可以忽略“jar will be empty - no content was marked for inclusion!“的警告）123At this point, you could import the project into an IDE (most modern Java IDEs include built-in support for Maven). For simplicity, we continue to use a plain text editor for this example. 在此刻，您可以导入该工程到IDE（所有的流行的javaIDE都支持导入Maven项目）。为了简化，我们继续使用纯文本编辑器编辑示例。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（四）：安装Spring Boot命令行界面","slug":"Spring BootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI","date":"2018-04-17T11:58:47.000Z","updated":"2018-04-20T03:27:53.991Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI/","excerpt":"","text":"10.2 Installing the Spring Boot CLI（安装Spring Boot命令行界面）1234567The Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code.You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI（命令行界面）是一个命令行工具，您可以使用它来快速使用Spring进行原型开发它允许您运行Groovy脚本，这意味着您不需要太多样板代码就能以类似于java的语法进行开发。尽管您不需要使用CLI去运行Spring Boot ，但这绝对是获得Spring应用程序的最快捷方式 10.2.1 Manual Installation（手动安装）12345678910You can download the Spring CLI distribution from the Spring software repository: • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gzCutting edge snapshot distributions are also available.Once downloaded, follow the INSTALL.txt instructions from the unpacked archive. In summary, there is a spring script (spring.bat for Windows) in a bin/directory in the .zip file. Alternatively, you can use java -jar with the .jar file (the script helps you to be sure that the classpath is set correctly). 您可以从Spring 软件远程库下载Spring CLI的分发版本• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gz最新的快照版本同样可用。下载以后，请参照解压出来的文档INSTALL.txt的介绍进行操作。综上所述，有一个spring脚本（windows 下用spring.bat）在bin目录下的.zip文件中。另外，你可以使用java -jar 启动.jar包（这个脚本帮助您确认类路径是否被正确设置） 10.2.2 Installation with SDKMAN!（通过SDKMAN安装）1234SDKMAN! (The Software Development Kit Manager) can be used for managing multiple versions of various binary SDKs, including Groovy and the Spring Boot CLI. Get SDKMAN! from sdkman.io and install Spring Boot by using the following commands: SDKMAN!（软件开发工具包管理器）可用于管理各种二进制SDK的多个版本，包括Groovy脚本和Spring Boot CLI.从sdkman.io中获取SDKMAN!并用以下命令进行Spring Boot 安装。123$ sdk install springboot$ spring --versionSpring Boot v2.1.0.BUILD-SNAPSHOT 12If you develop features for the CLI and want easy access to the version you built, use the following commands: 如果您为CLI开发功能并希望轻松访问您创建的版本，请使用以下命令： 12345$ sdk install springboot dev /path/to/spring-boot/spring-boot-cli/ target/spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin/spring-2.1.0.BUILD-SNAPSHOT/$ sdk default springboot dev$ spring --versionSpring CLI v2.1.0.BUILD-SNAPSHOT 12The preceding instructions install a local instance of spring called the dev instance. It points at your target build location, so every time you rebuild Spring Boot,spring is up-to-date.You can see it by running the following command: 之前介绍了如何安装一个被称之为dev实例的本地spring实例。它指向了您的目标构建地址，因此每次当您重新构建Spring Boot的时候spring也同步更新。您可以通过运行下列命令行查看它： 12345678910111213$ sdk ls springboot================================================================================Available Springboot Versions================================================================================&gt; + dev* 2.1.0.BUILD-SNAPSHOT================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 10.2.3 OSX Homebrew Installation(苹果系统下使用Homebrew安装）12If you are on a Mac and use Homebrew, you can install the Spring Boot CLI by using the following commands: 如果您使用的是Mac并且使用Homebrew命令，你可以安装Spring Boot CLI 通过以下命令： 12$ brew tap pivotal/tap$ brew install springboot 1Homebrew installs spring to /usr/local/bin. Homebrew将spring安装在/usr/local/bin路径下 12If you do not see the formula, your installation of brew might be out-of-date. In that case, run brew update and try again. 如果您没有看到该公式，那么您的brew的安装可能会过时。 在这种情况下，运行brew update并重试。 10.2.4 MacPorts Installation（以MacPorts安装方式）12If you are on a Mac and use MacPorts, you can install the Spring Boot CLI by using the following command: 如果您使用Mac，并且使用MacPorts，您可以通过以下命令安装Spring Boot CLI1$ sudo port install spring-boot-cli 10.2.5 Command-line Completion（命令行完成）123456789The Spring Boot CLI includes scripts that provide command completion for the BASH and zsh shells. You can source the script (also named spring) in any shell or put it in your personal or system-wide bash completion initialization. On a Debian system, the system-wide scripts are in /shell-completion/bash and all scripts in that directory are executed when a new shell starts. For example, to run the script manually if you have installed by using SDKMAN!, use the following commands: Spring Boot CLI为BASH和zsh shells提供了命令行完成脚本。您可以在任何shell或者您个人的或者系统范围内的bash中初始化source该脚本。在Debian系统，全系统脚本在/shell-completion/bash，并且所有新建的可执行脚本都在该路径下。比如说，在您已经安装使用SDKMAN的情况下，去手动运行该脚本，使用如下命令：123$ . ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring$ spring &lt;HIT TAB HERE&gt; grab help jar run test version 123If you install the Spring Boot CLI by using Homebrew or MacPorts, the command-line completion scripts are automatically registered with your shell. 如果您使用Homebrew或者MacPorts安装Spring Boot CLI命令行初始化完成，那么它会自动注册到您的shell当中。 10.2.6 Quick-start Spring CLI Example（快速开始Spring CLI 示例）12You can use the following web application to test your installation. To start, create a file called app.groovy, as follows: 您可以使用如下的web应用去测试您的安装情况。首先，创建一个如下的app.groovy： 123456789@RestControllerclass ThisWillActuallyRun &#123; @RequestMapping(\"/\") String home() &#123; \"Hello World!\" &#125;&#125; 1Then run it from a shell, as follows: 然后在shell中运行它，如下：1$ spring run app.groovy 12The first run of your application is slow, as dependencies are downloaded. Subsequent runs are much quicker. 首次运行您的应用会比较慢，因为依赖库需要被下载，以后每次运行会比较快12Open localhost:8080 in your favorite web browser. You should see the following output: 在您喜爱的浏览器中打开 localhost:8080 ，您将会看到如下的输出： 1Hello World! 10.3 Upgrading from an Earlier Version of Spring Boot（从一个旧版本升级Spring Boot）1234If you are upgrading from an earlier release of Spring Boot, check the “migration guide” on the project wiki that provides detailed upgrade instructions. Check also the“release notes” for a list of “new and noteworthy” features for each release. 如果您想从以前的版本中升级Spring Boot 请核对该项目在wiki上的“migration guide”，它提供了详细的升级说明。并且从列表中核对“relese notes”，每个relese版本都有新的值得注意的功能。 12345To upgrade an existing CLI installation, use the appropriate package manager command (for example, brew upgrade) or, if you manually installed the CLI, follow thestandard instructions, remembering to update your PATH environment variable to remove any older references. 去升级一个已有的CLI安装程序，推荐使用打包工具命令（比如 brew upgrage），如果您手动安装了CLI，根据标准的说明，记得更新您的环境变量去移除任何旧的关联","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（五）：部署你的第一个Spring Boot应用","slug":"Spring BootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用","date":"2018-04-17T11:50:47.000Z","updated":"2018-04-20T03:28:35.653Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用/","excerpt":"","text":"11. Developing Your First Spring Boot Application(部署你的第一个Spring Boot应用)123This section describes how to develop a simple “Hello World!” web application that highlights some of Spring Boot’s key features. We use Maven to build this project, since most IDEs support it. 本节讲述了如何部署一个简单的”Hello World”的Web应用，突出讲述了一些Spring Boot的关键功能。我们使用Maven去构建这个工程，因为大多数IDE支持它。 1234567The spring.io web site contains many “Getting Started” guides that use Spring Boot. If you need to solve a specific problem, check there first.You can shortcut the steps below by going to start.spring.io and choosing the &quot;Web&quot; starter from the dependencies searcher. Doing so generates a new project structure so that you can start coding right away. Check the Spring Initializr documentation for more details. spring.io网站包含了很多使用Spring Boot的“入门”向导。如果你需要解决一个特殊的问题，可以首先从那里寻找答案。您可以通过start.spring.io从依赖中找到“Web starter”来简化以下步骤。这样做会产生一个新的项目结构，以便您可以立即开始编码。查看Spring Initializr文档以获取更多详细信息。 12Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed: 在我们开始之前，打开terminal窗口，运行以下指令去确认您是否安装有符合版本的java和maven1234$ java -versionjava version \"1.8.0_102\"Java(TM) SE Runtime Environment (build 1.8.0_102-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) 1234$ mvn -vApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00)Maven home: /usr/local/Cellar/maven/3.3.9/libexecJava version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory. 此示例需要在其自己的文件夹中创建。随后说明假定您已经创建了合适的文件夹和它是你当前的目录。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（三）：安装部署Spring Boot","slug":"Spring BootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot","date":"2018-04-17T02:59:47.000Z","updated":"2018-04-20T03:27:17.057Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot/","excerpt":"","text":"10. Installing Spring Boot（安装部署Spring Boot）123456789Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Either way, you need Java SDK v1.8 or higher. Before you begin, you should check your current Java installation by using the following command: $ java -version If you are new to Java development or if you want to experiment with Spring Boot, you might want to try the Spring Boot CLI (Command Line Interface) first. Otherwise, read on for “classic” installation instructions. Spring Boot 可以被传统的java部署工具部署，也可以被安装为命令行工具。同样的，您需要java1.8或更高的版本支持。在您开始之前，您可以使用如下命令检查一下您的JDK版本1$ java -version 如果您是新部署一个应用或者您想尝试下Spring Boot ，您可以首先尝试使用Spring Boot CLI（命令行接口）。否则，请阅读“传统”安装介绍。 10.1 Installation Instructions for the Java Developer（针对java开发者的安装介绍）12345678910You can use Spring Boot in the same way as any standard Java library. To do so, include the appropriate spring-boot-*.jar files on your classpath. Spring Boot does not require any special tools integration, so you can use any IDE or text editor. Also, there is nothing special about a Spring Boot application, so you can run and debug a Spring Boot application as you would any other Java program. Although you could copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle). 您可以同样的使用Spring Boot作为一个标准的Java库。因此，您可以讲spring-boot-*.jar适当的引入到您的类路径下。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。并且，Spring Boot应用没有任何特殊之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。尽管您可以拷贝Spring Boot jar包，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。 10.1.1 Maven Installation（Maven下的安装）12Spring Boot is compatible with Apache Maven 3.2 or above. If you do not already have Maven installed, you can follow the instructions at maven.apache.org. Spring Boot与Apache Maven 3.2或更高版本兼容。 如果你尚未安装Maven，您可以按照maven.apache.org上的说明进行操作。 12345On many operating systems, Maven can be installed with a package manager. If you use OSX Homebrew, try brew install maven. Ubuntu users can run sudo apt-get install maven. Windows users with Chocolatey can run choco install maven from an elevated (administrator) prompt. 在很多系统中，Maven可以使用包管理器进行安装。如果您使用OSX系统的Homebrew，尝试brew install maven。Ubuntu用户可以运行 sudo apt-get 安装maven。 具有Chocolatey命令行管理包的Window用户可以以管理员的身份在示框中运行choco install maven 123456Spring Boot dependencies use the org.springframework.boot groupId. Typically, your Maven POM file inherits from the spring-boot-starter- parentproject and declares dependencies to one or more “Starters”. Spring Boot also provides an optional Maven plugin to create executable jars. The following listing shows a typical pom.xml file: Spring Boot 依赖使用 org.springframework.boot 作为groupId。通常，您的Maven POM文件继承于spring-boot-starter-parentproject 并且声明依赖于一个或者多个“Straters”。Sring Boot同样提供了可选的Maven插件去创建可运行jars包。以下列表展示了一个通常使用的pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- Add Spring repositories --&gt; &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 10.1.2 Gradle Installation（Gradle下的安装）1234567Spring Boot is compatible with Gradle 4. If you do not already have Gradle installed, you can follow the instructions at gradle.org.Spring Boot dependencies can be declared by using the org.springframework.boot group. Typically, your project declares dependencies to one or more“Starters”. Spring Boot provides a useful Gradle plugin that can be used to simplify dependency declarations and to create executable jars. Spring Boot 兼容Gradle 4. 如果您还没有安装Gradle，您可以从 gradle.org中获取介绍文档。Spring Boot依赖可以被声明为org.springframework.boot group。通常，您的项目被声明依赖于一个或者多个“Strarters”。Spring Boot 提供可用的Gradle 插件用于简化依赖声明和创建可执行jars包。 12345Gradle WrapperThe Gradle Wrapper provides a nice way of “obtaining” Gradle when you need to build a project. It is a small script and library that you commit alongside your code to bootstrap the build process. See docs.gradle.org/4.2.1/userguide/gradle_wrapper.html for details. Gradle 包装当您去构建您的应用时，Gradle 包装提供了一个优雅的路径去“获得”Gradle。他提供了一个小脚本和库似的您的提交和构建同步进行。具体参见：docs.gradle.org/4.2.1/userguide/gradle_wrapper.html 1The following example shows a typical build.gradle file: 以下为一个通常的build.gradle文件 123456789101112131415161718192021222324252627282930buildscript &#123; repositories &#123; jcenter() maven &#123; url 'https://repo.spring.io/snapshot' &#125; maven &#123; url 'https://repo.spring.io/milestone' &#125; &#125; dependencies &#123; classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.1.0.BUILD-SNAPSHOT' &#125;&#125;apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter() maven &#123; url \"https://repo.spring.io/snapshot\" &#125; maven &#123; url \"https://repo.spring.io/milestone\" &#125;&#125;dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-web\") testCompile(\"org.springframework.boot:spring-boot-starter-test\")&#125;","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（二）：系统依赖","slug":"Spring BootDoc第二部分/SpringBoot翻译（二）系统依赖","date":"2018-04-17T02:58:47.000Z","updated":"2018-04-20T03:25:20.472Z","comments":true,"path":"2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（二）系统依赖/","link":"","permalink":"http://yoursite.com/2018/04/17/Spring BootDoc第二部分/SpringBoot翻译（二）系统依赖/","excerpt":"","text":"9 . System Requirements（系统依赖）123Spring Boot 2.1.0.BUILD-SNAPSHOT requires Java 8 or 9 and Spring Framework 5.0.5.RELEASE or above. Explicit build support is provided for Maven 3.2+ and Gradle 4. Spring Boot 2.1。0.BUILD-SNAPSHOT 需要java8或者java9版本，以及Spring Framework 5.0.5.RELEASE 或更高版本。为Maven 3.2+和Gradle 4提供了明确的支持。 9.1 Servlet Containers（Servlet 容器）1Spring Boot supports the following embedded servlet containers: Spring Boot支持如下内置容器 Name Servlet Version Tomcat 8.5 3.1 Jetty 9.4 3.1 Undertow 1.4 3.1 1You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 您也可以部署Spring Boot应用在任何的基于Servlet 3.1+版本的容器中","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（一）：介绍 Spring Boot","slug":"Spring BootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot","date":"2018-04-16T14:58:47.000Z","updated":"2018-04-20T03:24:48.456Z","comments":true,"path":"2018/04/16/Spring BootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/16/Spring BootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot/","excerpt":"","text":"Part II. Getting Started篇章二. 开始123456If you are getting started with Spring Boot,or “Spring” in general, start by reading this section. It answers the basic “what?”, “how?” and “why?” questions.It includes an introduction to Spring Boot, along with installation instructions.We then walk you through building your first Spring Boot application, discussing some core principles as we go. 一般来说，您可以从阅读本章节开始学习Spring Boot 或者Spring。本节回答了最基础的“什么？”，“如何？”，“为何？”等问题。它包括了介绍Spring Boot如何独立部署的说明。我们将带领您建设您得第一个SpringBoot应用，跟随我们一起去探讨一些Spring Boot的核心价值。 8 . Introducing Spring Boot（介绍 Spring Boot）12345Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使您能够非常简单的创建一个可运行的基于Spring的，产品级别的，独立部署应用。我们用我们自己认为的观点来处理Spring平台和第三方库，以便于您能够以最小的代价开始您的应用。所有的Spring Boot应用都只需要很少的Spring配置123You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. 你能够在Spring Boot 中使用java -jar 或者更为传统的 war包去创建java应用。我们同样提供了命令行工具去运行“Spring脚本”。12345678910Our primary goals are:* Provide a radically faster and widely accessible getting-started experience for all Spring development.* Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.* Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).* Absolutely no code generation and no requirement for XML configuration. 我们的主要目标 • 为所有的基于Spring的开发提供一个更快的，更广泛的入门级体验。 • 以自我认为的方式通过一些默认的最快速基本的配置实现开箱即用的体验。 • 提供大型项目（如内置服务器，安全性，埋点，运行状况检查和外部配置）通用的一系列非产品功能性的功能。 • 绝对不需要生成代码或者xml的配置。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"消除过期的对象引用（六）","slug":"读书笔记/消除过期的对象引用","date":"2017-12-04T14:19:47.000Z","updated":"2017-12-04T15:27:51.000Z","comments":true,"path":"2017/12/04/读书笔记/消除过期的对象引用/","link":"","permalink":"http://yoursite.com/2017/12/04/读书笔记/消除过期的对象引用/","excerpt":"","text":"消除过期的对象引用书中的例子如下:问题出在pop方法上，pop出去以后，stack的size本身减少1，size–，外部会持有该对象的引用，但是即便外部释放掉该element的引用，stack本身还有一个“保护机制”，栈内部会维护着这个对象的过期引用。为什么呢？这个是数组的特性，好比创建了一个16大小的数组，调用pop方法相当于这时候对第16个数组对象创建一个外部引用，这个对象本身还是在内存中有空间的。换而言之，这个第16个对象此时此刻即被外部调用的一个引用持有，也同时被stack本身的数组持有，也许有人认为–size了，现在应该变为15大小的数组了，为什么还持有第16个呢？这里首先要理解数组对象创建的时候内存的变化。声明数组过程中，变量保存在栈中，创建并进行初始化时，数组元素是保存在堆中，数组通过引用指针指向数组元素。对于基本类型数组的初始化，程序直接先为数组分配内存空间，再将数组元素的值存入对应的内存里。对于引用类型数组的数组元素依然是引用类型，因此数组元素里存储的还是引用，它指向另一块内存，该内在里存储了该引用变量所引用的对象。这里的size其实只是栈中一个域变量的变化，而非真正数组的变化，原来作为基本类型的引用依然存在于第16个数组的位置上。 1234567891011121314151617181920212223242526public class Stack &#123; pprivate Object[] elements; private int size = 0; private static final int DEFAULT_INITAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if(size == 0) &#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 术语：过期引用（obsolete reference) ，指永远不会被解除的引用。 书中也给了修改得方式如下：12345678public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; Object result = elements[--size]; elements[size] = null; return result;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"私有化构造函数强化不可实例化的类，避免创建不必要的对象（四，五）","slug":"读书笔记/通过私有化构造函数强化不可实例化的类","date":"2017-12-04T11:19:47.000Z","updated":"2017-12-04T15:26:55.000Z","comments":true,"path":"2017/12/04/读书笔记/通过私有化构造函数强化不可实例化的类/","link":"","permalink":"http://yoursite.com/2017/12/04/读书笔记/通过私有化构造函数强化不可实例化的类/","excerpt":"","text":"通过私有化构造函数强化不可实例化的类这个个人理解就是因为有默认构造函数的原因，如果是显示声明私有化的话则不可实例化，或者只能通过本身来提供实例。但是对于某些工具类，如Collections，更希望即便在内部也不要私有化，书中给出一种方案，我们一Collections类为例 1234// Suppresses default constructor, ensuring non-instantiability.private Collections() &#123; throw new AssertionError();//可有可以无，但是有的情况下，可以有效防止内部不小心实例化&#125; 避免创建不必要的对象其实鼓励能够使用单例的或者静态工厂的尽量使用，这样可以少创建无用对象，这样能减轻垃圾回收的压力，可以很好的提升性能。 1234String s = new String(\"stringette\");//这种写法会制造不必要的String实例,\"stringette\"本身就是一个实例，再使用new会再创建一个实例String ss = \"stringette\"; //这种写法会复用一个实例，即便在多次调用的情况下，该实例被保存在字符串常量池中 可以参考下这篇文章：https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html 优先使用基本类型，而非装箱类型，这里装箱的时候回产生新的对象。下面这个例子测试时间分别为8483ms和775ms相差有10倍之多123456789101112131415161718192021222324252627package com.stardust.effective.role4And5;/** * Created by mike on 2017/12/4. */public class LongTest &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //获取开始时间 Long sum = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i; &#125; long middle = System.currentTimeMillis(); //获取中间时间 System.out.println(middle-start); long sum2 = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum2 += i; &#125; long end = System.currentTimeMillis(); //获取结束时间 System.out.println(end-middle); &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"用私有构造器或者枚举强化单例（三）","slug":"读书笔记/用私有构造器或者枚举强化单例","date":"2017-12-03T14:58:47.000Z","updated":"2017-12-04T11:20:25.000Z","comments":true,"path":"2017/12/03/读书笔记/用私有构造器或者枚举强化单例/","link":"","permalink":"http://yoursite.com/2017/12/03/读书笔记/用私有构造器或者枚举强化单例/","excerpt":"","text":"用私有构造器或者枚举强化单例首先对单单例，构造函数需要私有化，这样能够极大的保障外部无法直接实例化该对象单例在面试中经常会有面试官要求写，下面列出几种常用的写法： 懒汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 12345678910 public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 1234567 public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 对于上面这种写法，在书中有提到如果首行代码是public的话可以通过反射机制多实例化对象。如下举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.stardust.effective.role3;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by mike on 2017/12/3. */public class Singleton &#123; public static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Singleton s1 = null; Singleton s2 = null; Singleton s3 = Singleton.getInstance(); Singleton s4 = Singleton.getInstance(); if (s3==s4)&#123; System.out.println(\"通过静态工厂获取到的单例是唯一的\"); &#125;else &#123; System.out.println(\"静态工厂获取的单例不唯一\"); &#125; Constructor&lt;?&gt; constructor = Singleton.class.getDeclaredConstructors()[0]; constructor.setAccessible(true); try &#123; s1 = (Singleton) constructor.newInstance(); s2 = (Singleton) constructor.newInstance(); if(s1!=s2)&#123; System.out.println(\"构造出两个不同的实例\"); &#125;else &#123; System.out.println(\"始终为单例\"); &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举实现单例，这个是effective java书中推荐的实现方式，枚举天然私有构造，final，static等特性，可以生产一个懒加载的单例123456public enum Singletons &#123; INSTANCE; public void say() &#123; System.out.println(\"animal say\"); &#125;&#125; 从网上找的一个具体的例子，SomeThing.INSTANCE.getInstance() 即可获得所要实例12345678910111213class Resource&#123;&#125;public enum SomeThing &#123; INSTANCE; private Resource instance; SomeThing() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用构建器（二）","slug":"读书笔记/考虑使用构建器","date":"2017-12-03T06:58:47.000Z","updated":"2017-12-03T14:50:25.000Z","comments":true,"path":"2017/12/03/读书笔记/考虑使用构建器/","link":"","permalink":"http://yoursite.com/2017/12/03/读书笔记/考虑使用构建器/","excerpt":"","text":"考虑使用构建器这个比较好理解，能够解决多参数构造器的复杂性，相对于get和set的JavaBean来说也有线程安全性的优势，个人倾向于使用lombok的@Builder注解，注解虽好用，不过也需要了解下注解背后的一些原理。 先看一下我写的一个简单示例 12345678910111213@Builderpublic class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person p = Person.builder().age(15).build(); &#125; &#125; 再看下官方的标准示例 1234567891011//使用lombok注解的import lombok.Builder;import java.util.Set;@Builderpublic class BuilderExample &#123; private String name; private int age; @Singular private Set&lt;String&gt; occupations;&#125; 等效代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Set;class BuilderExample &#123; private String name; private int age; private Set&lt;String&gt; occupations; BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123; this.name = name; this.age = age; this.occupations = occupations; &#125; public static BuilderExampleBuilder builder() &#123; return new BuilderExampleBuilder(); &#125; public static class BuilderExampleBuilder &#123; private String name; private int age; private java.util.ArrayList&lt;String&gt; occupations; BuilderExampleBuilder() &#123; &#125; public BuilderExampleBuilder name(String name) &#123; this.name = name; return this; &#125; public BuilderExampleBuilder age(int age) &#123; this.age = age; return this; &#125; public BuilderExampleBuilder occupation(String occupation) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.add(occupation); return this; &#125; public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.addAll(occupations); return this; &#125; public BuilderExampleBuilder clearOccupations() &#123; if (this.occupations != null) &#123; this.occupations.clear(); &#125; return this; &#125; public BuilderExample build() &#123; // complicated switch statement to produce a compact properly sized immutable set omitted. // go to https://projectlombok.org/features/Singular-snippet.html to see it. Set&lt;String&gt; occupations = ...; return new BuilderExample(name, age, occupations); &#125; @java.lang.Override public String toString() &#123; return \"BuilderExample.BuilderExampleBuilder(name = \" + this.name + \", age = \" + this.age + \", occupations = \" + this.occupations + \")\"; &#125; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用静态工厂方法代替构造器（一）","slug":"读书笔记/考虑使用静态工厂方法代替构造器","date":"2017-11-30T11:58:47.000Z","updated":"2017-12-03T14:23:05.000Z","comments":true,"path":"2017/11/30/读书笔记/考虑使用静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2017/11/30/读书笔记/考虑使用静态工厂方法代替构造器/","excerpt":"","text":"考虑用静态工厂方法代替构造器优点它们有名称 指的是方法的名称，能够准确描述返回的对象，对于多个构造方法的类可以使用不同的名称来描述返回对象 对于构造方法参数的含义需要结合注释才能明白用哪一个构造器，并且多构造器的时候无法确切知道使用哪个构造器 12345678910111213141516171819202122232425262728293031323334package com.stardust.effective.role1;/** * Created by mike on 2017/12/3. * 它们有名称 */public class Fruit &#123; private String color; private String size; private Fruit(String color,String size)&#123; this.color=color; this.size=size; &#125; /** * 通过方法名可以知道要构造什么样的对象 * @return */ public static Fruit getBigGreenFruit()&#123; return new Fruit(\"green\",\"big\"); &#125; public static Fruit getSmallRedFruit()&#123; return new Fruit(\"red\",\"small\"); &#125; public static Fruit getApple()&#123; return new Fruit(\"red\",\"middle\"); &#125;&#125; 不必每次调用的时候都创建一个新对象单例模式，对于一些不可变类可以使用这种方式，在上面那个例子中我对构造函数进行了私有化，可以认为是一个简单的单例，但还是需要升级优化，在后面单例的几种写法中展开说。这种方式的一个优势即不必重复创建对象，在spring中大量使用单例这种设计模式来创建单一不可变对象。书中还提到一个如果实例受控则可以通过==来判定是否为同一实例，这种写法比equals提升了性能。 术语：实例受控的类(instance-controlled)：在某个时刻只能有某些规定的该类的实例存在。 可以返回原返回类型的任何子类型的对象文章中是以Collections为例的，一开始没有太理解，Collections是一个工具类，构造私有化的，不能直接实例化，Collection本身是接口，不能有静态工厂方法，所以委托给Collections这个工具类来提供生产构造.下面贴一段Collection中静态工厂的例子，以List为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns an immutable list containing only the specified object. * The returned list is serializable. * * @param &lt;T&gt; the class of the objects in the list * @param o the sole object to be stored in the returned list. * @return an immutable list containing only the specified object. * @since 1.3 */public static &lt;T&gt; List&lt;T&gt; singletonList(T o) &#123; return new SingletonList&lt;&gt;(o);&#125;/** * @serial include */private static class SingletonList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; private static final long serialVersionUID = 3093736618740652951L; private final E element; SingletonList(E obj) &#123;element = obj;&#125; public Iterator&lt;E&gt; iterator() &#123; return singletonIterator(element); &#125; public int size() &#123;return 1;&#125; public boolean contains(Object obj) &#123;return eq(obj, element);&#125; public E get(int index) &#123; if (index != 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: 1\"); return element; &#125; // Override default methods for Collection @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; action.accept(element); &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; throw new UnsupportedOperationException(); &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; throw new UnsupportedOperationException(); &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return singletonSpliterator(element); &#125;&#125;``` 术语：基于接口的框架(interface-based framework)：框架的对外访问与接入渠道是基于接口实现的。#### 在创建参数化类型实例的时候，使代码更加简洁``` java// 当前做法Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();// 举例这样做会更简洁Map&lt;String, List&lt;String&gt;&gt; map = HashMap.newInstance();// java8已经可以直接这样写了Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 缺点类如果不含public或者protected的构造器, 就不能被子类化 例如Collections类，不能被子类化，另一方面就是相当于鼓励复合（Composition），类似于用Collections这类的写法 无法与其他静态方法区分，不像构造方法名称必须为类名，可以使用一些惯用的名称来弥补这一劣势 valueOf() : 类型转换方法, 返回的实例与参数具有相同的值. of() : valueOf()的一种更简洁的替代. getInstance(): 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例. newInstance(): 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同. getType() : 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用. newType() : 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"博客使用示例","slug":"博客使用说明","date":"2017-11-29T09:40:59.000Z","updated":"2018-04-20T03:23:35.961Z","comments":true,"path":"2017/11/29/博客使用说明/","link":"","permalink":"http://yoursite.com/2017/11/29/博客使用说明/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo s More info: Server Generate static files1$ hexo g More info: Generating Deploy to remote sites1$ hexo d More info: Deployment 外链工厂图片图片一：http://www.wailian.work/images/2018/04/20/1524194203156.jpg图片二：http://www.wailian.work/images/2018/04/20/1524194162815.jpg图片三：http://www.wailian.work/images/2018/04/20/1524194188729.jpg图片四：http://www.wailian.work/images/2018/04/17/1523962657339.jpg图片五：http://www.wailian.work/images/2018/04/17/1523962773687.jpg图片六：http://www.wailian.work/images/2018/04/17/1523962729983.jpg图片七：http://www.wailian.work/images/2018/04/17/1523962638880.jpg图片八：http://www.wailian.work/images/2018/04/17/1523962692577.jpg图片九：http://www.wailian.work/images/2018/04/17/1523932533990.jpg图片十：http://www.wailian.work/images/2018/04/17/1523931297126.jpg","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"Mark Down语法","slug":"Markdown语法","date":"2017-11-29T09:39:59.000Z","updated":"2017-11-29T09:43:33.000Z","comments":true,"path":"2017/11/29/Markdown语法/","link":"","permalink":"http://yoursite.com/2017/11/29/Markdown语法/","excerpt":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多","text":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]}]}