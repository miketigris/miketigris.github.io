{"meta":{"title":"博客","subtitle":"技术博客","description":"许贵荣","author":"许贵荣个人版权所有","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringBoot官方文档翻译（四）：安装Spring Boot命令行界面","slug":"SpringBoot翻译（四）安装部署Spring Boot CLI","date":"2018-04-17T02:58:47.000Z","updated":"2018-04-17T08:03:59.399Z","comments":true,"path":"2018/04/17/SpringBoot翻译（四）安装部署Spring Boot CLI/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBoot翻译（四）安装部署Spring Boot CLI/","excerpt":"","text":"10.2 Installing the Spring Boot CLI（安装Spring Boot命令行界面）1234567The Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code.You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI（命令行界面）是一个命令行工具，您可以使用它来快速使用Spring进行原型开发它允许您运行Groovy脚本，这意味着您不需要太多样板代码就能以类似于java的语法进行开发。尽管您不需要使用CLI去运行Spring Boot ，但这绝对是获得Spring应用程序的最快捷方式 10.2.1 Manual Installation（手动安装）12345678910You can download the Spring CLI distribution from the Spring software repository: • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gzCutting edge snapshot distributions are also available.Once downloaded, follow the INSTALL.txt instructions from the unpacked archive. In summary, there is a spring script (spring.bat for Windows) in a bin/directory in the .zip file. Alternatively, you can use java -jar with the .jar file (the script helps you to be sure that the classpath is set correctly). 您可以从Spring 软件远程库下载Spring CLI的分发版本• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gz最新的快照版本同样可用。下载以后，请参照解压出来的文档INSTALL.txt的介绍进行操作。综上所述，有一个spring脚本（windows 下用spring.bat）在bin目录下的.zip文件中。另外，你可以使用java -jar 启动.jar包（这个脚本帮助您确认类路径是否被正确设置） 10.2.2 Installation with SDKMAN!（通过SDKMAN安装）1234SDKMAN! (The Software Development Kit Manager) can be used for managing multiple versions of various binary SDKs, including Groovy and the Spring Boot CLI. Get SDKMAN! from sdkman.io and install Spring Boot by using the following commands: SDKMAN!（软件开发工具包管理器）可用于管理各种二进制SDK的多个版本，包括Groovy脚本和Spring Boot CLI.从sdkman.io中获取SDKMAN!并用以下命令进行Spring Boot 安装。123$ sdk install springboot$ spring --versionSpring Boot v2.1.0.BUILD-SNAPSHOT 12If you develop features for the CLI and want easy access to the version you built, use the following commands: 如果您为CLI开发功能并希望轻松访问您创建的版本，请使用以下命令： 12345$ sdk install springboot dev /path/to/spring-boot/spring-boot-cli/ target/spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin/spring-2.1.0.BUILD-SNAPSHOT/$ sdk default springboot dev$ spring --versionSpring CLI v2.1.0.BUILD-SNAPSHOT 12The preceding instructions install a local instance of spring called the dev instance. It points at your target build location, so every time you rebuild Spring Boot,spring is up-to-date.You can see it by running the following command: 之前介绍了如何安装一个被称之为dev实例的本地spring实例。它指向了您的目标构建地址，因此每次当您重新构建Spring Boot的时候spring也同步更新。您可以通过运行下列命令行查看它： 12345678910111213$ sdk ls springboot================================================================================Available Springboot Versions================================================================================&gt; + dev* 2.1.0.BUILD-SNAPSHOT================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 10.2.3 OSX Homebrew Installation(苹果系统下使用Homebrew安装）12If you are on a Mac and use Homebrew, you can install the Spring Boot CLI by using the following commands: 如果您使用的是Mac并且使用Homebrew命令，你可以安装Spring Boot CLI 通过以下命令： 12$ brew tap pivotal/tap$ brew install springboot 1Homebrew installs spring to /usr/local/bin. Homebrew将spring安装在/usr/local/bin路径下 12If you do not see the formula, your installation of brew might be out-of-date. In that case, run brew update and try again. 如果您没有看到该公式，那么您的brew的安装可能会过时。 在这种情况下，运行brew update并重试。 10.2.4 MacPorts Installation（以MacPorts安装方式）12If you are on a Mac and use MacPorts, you can install the Spring Boot CLI by using the following command: 如果您使用Mac，并且使用MacPorts，您可以通过以下命令安装Spring Boot CLI1$ sudo port install spring-boot-cli 10.2.5 Command-line Completion（命令行完成）123456789The Spring Boot CLI includes scripts that provide command completion for the BASH and zsh shells. You can source the script (also named spring) in any shell or put it in your personal or system-wide bash completion initialization. On a Debian system, the system-wide scripts are in /shell-completion/bash and all scripts in that directory are executed when a new shell starts. For example, to run the script manually if you have installed by using SDKMAN!, use the following commands: Spring Boot CLI为BASH和zsh shells提供了命令行完成脚本。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot官方文档翻译（三）：安装部署Spring Boot","slug":"SpringBoot翻译（三）安装部署Spring Boot","date":"2018-04-17T02:58:47.000Z","updated":"2018-04-17T03:57:27.465Z","comments":true,"path":"2018/04/17/SpringBoot翻译（三）安装部署Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBoot翻译（三）安装部署Spring Boot/","excerpt":"","text":"10. Installing Spring Boot（安装部署Spring Boot）123456789Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Either way, you need Java SDK v1.8 or higher. Before you begin, you should check your current Java installation by using the following command: $ java -version If you are new to Java development or if you want to experiment with Spring Boot, you might want to try the Spring Boot CLI (Command Line Interface) first. Otherwise, read on for “classic” installation instructions. Spring Boot 可以被传统的java部署工具部署，也可以被安装为命令行工具。同样的，您需要java1.8或更高的版本支持。在您开始之前，您可以使用如下命令检查一下您的JDK版本1$ java -version 如果您是新部署一个应用或者您想尝试下Spring Boot ，您可以首先尝试使用Spring Boot CLI（命令行接口）。否则，请阅读“传统”安装介绍。 10.1 Installation Instructions for the Java Developer（针对java开发者的安装介绍）12345678910You can use Spring Boot in the same way as any standard Java library. To do so, include the appropriate spring-boot-*.jar files on your classpath. Spring Boot does not require any special tools integration, so you can use any IDE or text editor. Also, there is nothing special about a Spring Boot application, so you can run and debug a Spring Boot application as you would any other Java program. Although you could copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle). 您可以同样的使用Spring Boot作为一个标准的Java库。因此，您可以讲spring-boot-*.jar适当的引入到您的类路径下。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。并且，Spring Boot应用没有任何特殊之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。尽管您可以拷贝Spring Boot jar包，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。 10.1.1 Maven Installation（Maven下的安装）12Spring Boot is compatible with Apache Maven 3.2 or above. If you do not already have Maven installed, you can follow the instructions at maven.apache.org. Spring Boot与Apache Maven 3.2或更高版本兼容。 如果你尚未安装Maven，您可以按照maven.apache.org上的说明进行操作。 12345On many operating systems, Maven can be installed with a package manager. If you use OSX Homebrew, try brew install maven. Ubuntu users can run sudo apt-get install maven. Windows users with Chocolatey can run choco install maven from an elevated (administrator) prompt. 在很多系统中，Maven可以使用包管理器进行安装。如果您使用OSX系统的Homebrew，尝试brew install maven。Ubuntu用户可以运行 sudo apt-get 安装maven。 具有Chocolatey命令行管理包的Window用户可以以管理员的身份在示框中运行choco install maven 123456Spring Boot dependencies use the org.springframework.boot groupId. Typically, your Maven POM file inherits from the spring-boot-starter- parentproject and declares dependencies to one or more “Starters”. Spring Boot also provides an optional Maven plugin to create executable jars. The following listing shows a typical pom.xml file: Spring Boot 依赖使用 org.springframework.boot 作为groupId。通常，您的Maven POM文件继承于spring-boot-starter-parentproject 并且声明依赖于一个或者多个“Straters”。Sring Boot同样提供了可选的Maven插件去创建可运行jars包。以下列表展示了一个通常使用的pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- Add Spring repositories --&gt; &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 10.1.2 Gradle Installation（Gradle下的安装）1234567Spring Boot is compatible with Gradle 4. If you do not already have Gradle installed, you can follow the instructions at gradle.org.Spring Boot dependencies can be declared by using the org.springframework.boot group. Typically, your project declares dependencies to one or more“Starters”. Spring Boot provides a useful Gradle plugin that can be used to simplify dependency declarations and to create executable jars. Spring Boot 兼容Gradle 4. 如果您还没有安装Gradle，您可以从 gradle.org中获取介绍文档。Spring Boot依赖可以被声明为org.springframework.boot group。通常，您的项目被声明依赖于一个或者多个“Strarters”。Spring Boot 提供可用的Gradle 插件用于简化依赖声明和创建可执行jars包。 12345Gradle WrapperThe Gradle Wrapper provides a nice way of “obtaining” Gradle when you need to build a project. It is a small script and library that you commit alongside your code to bootstrap the build process. See docs.gradle.org/4.2.1/userguide/gradle_wrapper.html for details. Gradle 包装当您去构建您的应用时，Gradle 包装提供了一个优雅的路径去“获得”Gradle。他提供了一个小脚本和库似的您的提交和构建同步进行。具体参见：docs.gradle.org/4.2.1/userguide/gradle_wrapper.html 1The following example shows a typical build.gradle file: 以下为一个通常的build.gradle文件 123456789101112131415161718192021222324252627282930buildscript &#123; repositories &#123; jcenter() maven &#123; url &apos;https://repo.spring.io/snapshot&apos; &#125; maven &#123; url &apos;https://repo.spring.io/milestone&apos; &#125; &#125; dependencies &#123; classpath &apos;org.springframework.boot:spring-boot-gradle-plugin:2.1.0.BUILD-SNAPSHOT&apos; &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;io.spring.dependency-management&apos;jar &#123; baseName = &apos;myproject&apos; version = &apos;0.0.1-SNAPSHOT&apos;&#125;repositories &#123; jcenter() maven &#123; url &quot;https://repo.spring.io/snapshot&quot; &#125; maven &#123; url &quot;https://repo.spring.io/milestone&quot; &#125;&#125;dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)&#125;","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot官方文档翻译（二）：系统依赖","slug":"SpringBoot翻译（二）系统依赖","date":"2018-04-17T02:58:47.000Z","updated":"2018-04-17T02:27:37.189Z","comments":true,"path":"2018/04/17/SpringBoot翻译（二）系统依赖/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBoot翻译（二）系统依赖/","excerpt":"","text":"9 . System Requirements（系统依赖）123Spring Boot 2.1.0.BUILD-SNAPSHOT requires Java 8 or 9 and Spring Framework 5.0.5.RELEASE or above. Explicit build support is provided for Maven 3.2+ and Gradle 4. Spring Boot 2.1。0.BUILD-SNAPSHOT 需要java8或者java9版本，以及Spring Framework 5.0.5.RELEASE 或更高版本。为Maven 3.2+和Gradle 4提供了明确的支持。 9.1 Servlet Containers（Servlet 容器）1Spring Boot supports the following embedded servlet containers: Spring Boot支持如下内置容器 Name Servlet Version Tomcat 8.5 3.1 Jetty 9.4 3.1 Undertow 1.4 3.1 1You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 您也可以部署Spring Boot应用在任何的基于Servlet 3.1+版本的容器中","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot官方文档翻译（一）：介绍 Spring Boot","slug":"SpringBoot翻译（一）介绍 Spring Boot","date":"2018-04-16T14:58:47.000Z","updated":"2018-04-17T02:16:22.067Z","comments":true,"path":"2018/04/16/SpringBoot翻译（一）介绍 Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/16/SpringBoot翻译（一）介绍 Spring Boot/","excerpt":"","text":"Part II. Getting Started篇章二. 开始123456If you are getting started with Spring Boot,or “Spring” in general, start by reading this section. It answers the basic “what?”, “how?” and “why?” questions.It includes an introduction to Spring Boot, along with installation instructions.We then walk you through building your first Spring Boot application, discussing some core principles as we go. 一般来说，您可以从阅读本章节开始学习Spring Boot 或者Spring。本节回答了最基础的“什么？”，“如何？”，“为何？”等问题。它包括了介绍Spring Boot如何独立部署的说明。我们将带领您建设您得第一个SpringBoot应用，跟随我们一起去探讨一些Spring Boot的核心价值。 8 . Introducing Spring Boot（介绍 Spring Boot）12345Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使您能够非常简单的创建一个可运行的基于Spring的，产品级别的，独立部署应用。我们用我们自己认为的观点来处理Spring平台和第三方库，以便于您能够以最小的代价开始您的应用。所有的Spring Boot应用都只需要很少的Spring配置123You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. 你能够在Spring Boot 中使用java -jar 或者更为传统的 war包去创建java应用。我们同样提供了命令行工具去运行“Spring脚本”。12345678910Our primary goals are:* Provide a radically faster and widely accessible getting-started experience for all Spring development.* Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.* Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).* Absolutely no code generation and no requirement for XML configuration. 我们的主要目标 • 为所有的基于Spring的开发提供一个更快的，更广泛的入门级体验。 • 以自我认为的方式通过一些默认的最快速基本的配置实现开箱即用的体验。 • 提供大型项目（如内置服务器，安全性，埋点，运行状况检查和外部配置）通用的一系列非产品功能性的功能。 • 绝对不需要生成代码或者xml的配置。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"消除过期的对象引用（六）","slug":"消除过期的对象引用","date":"2017-12-04T14:19:47.000Z","updated":"2017-12-04T15:27:51.000Z","comments":true,"path":"2017/12/04/消除过期的对象引用/","link":"","permalink":"http://yoursite.com/2017/12/04/消除过期的对象引用/","excerpt":"","text":"消除过期的对象引用书中的例子如下:问题出在pop方法上，pop出去以后，stack的size本身减少1，size–，外部会持有该对象的引用，但是即便外部释放掉该element的引用，stack本身还有一个“保护机制”，栈内部会维护着这个对象的过期引用。为什么呢？这个是数组的特性，好比创建了一个16大小的数组，调用pop方法相当于这时候对第16个数组对象创建一个外部引用，这个对象本身还是在内存中有空间的。换而言之，这个第16个对象此时此刻即被外部调用的一个引用持有，也同时被stack本身的数组持有，也许有人认为–size了，现在应该变为15大小的数组了，为什么还持有第16个呢？这里首先要理解数组对象创建的时候内存的变化。声明数组过程中，变量保存在栈中，创建并进行初始化时，数组元素是保存在堆中，数组通过引用指针指向数组元素。对于基本类型数组的初始化，程序直接先为数组分配内存空间，再将数组元素的值存入对应的内存里。对于引用类型数组的数组元素依然是引用类型，因此数组元素里存储的还是引用，它指向另一块内存，该内在里存储了该引用变量所引用的对象。这里的size其实只是栈中一个域变量的变化，而非真正数组的变化，原来作为基本类型的引用依然存在于第16个数组的位置上。 1234567891011121314151617181920212223242526public class Stack &#123; pprivate Object[] elements; private int size = 0; private static final int DEFAULT_INITAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if(size == 0) &#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 术语：过期引用（obsolete reference) ，指永远不会被解除的引用。 书中也给了修改得方式如下：12345678public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; Object result = elements[--size]; elements[size] = null; return result;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"私有化构造函数强化不可实例化的类，避免创建不必要的对象（四，五）","slug":"通过私有化构造函数强化不可实例化的类","date":"2017-12-04T11:19:47.000Z","updated":"2017-12-04T15:26:55.000Z","comments":true,"path":"2017/12/04/通过私有化构造函数强化不可实例化的类/","link":"","permalink":"http://yoursite.com/2017/12/04/通过私有化构造函数强化不可实例化的类/","excerpt":"","text":"通过私有化构造函数强化不可实例化的类这个个人理解就是因为有默认构造函数的原因，如果是显示声明私有化的话则不可实例化，或者只能通过本身来提供实例。但是对于某些工具类，如Collections，更希望即便在内部也不要私有化，书中给出一种方案，我们一Collections类为例 1234// Suppresses default constructor, ensuring non-instantiability.private Collections() &#123; throw new AssertionError();//可有可以无，但是有的情况下，可以有效防止内部不小心实例化&#125; 避免创建不必要的对象其实鼓励能够使用单例的或者静态工厂的尽量使用，这样可以少创建无用对象，这样能减轻垃圾回收的压力，可以很好的提升性能。 1234String s = new String(\"stringette\");//这种写法会制造不必要的String实例,\"stringette\"本身就是一个实例，再使用new会再创建一个实例String ss = \"stringette\"; //这种写法会复用一个实例，即便在多次调用的情况下，该实例被保存在字符串常量池中 可以参考下这篇文章：https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html 优先使用基本类型，而非装箱类型，这里装箱的时候回产生新的对象。下面这个例子测试时间分别为8483ms和775ms相差有10倍之多123456789101112131415161718192021222324252627package com.stardust.effective.role4And5;/** * Created by mike on 2017/12/4. */public class LongTest &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //获取开始时间 Long sum = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i; &#125; long middle = System.currentTimeMillis(); //获取中间时间 System.out.println(middle-start); long sum2 = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum2 += i; &#125; long end = System.currentTimeMillis(); //获取结束时间 System.out.println(end-middle); &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"用私有构造器或者枚举强化单例（三）","slug":"用私有构造器或者枚举强化单例","date":"2017-12-03T14:58:47.000Z","updated":"2017-12-04T11:20:25.000Z","comments":true,"path":"2017/12/03/用私有构造器或者枚举强化单例/","link":"","permalink":"http://yoursite.com/2017/12/03/用私有构造器或者枚举强化单例/","excerpt":"","text":"用私有构造器或者枚举强化单例首先对单单例，构造函数需要私有化，这样能够极大的保障外部无法直接实例化该对象单例在面试中经常会有面试官要求写，下面列出几种常用的写法： 懒汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 12345678910 public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 1234567 public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 对于上面这种写法，在书中有提到如果首行代码是public的话可以通过反射机制多实例化对象。如下举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.stardust.effective.role3;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by mike on 2017/12/3. */public class Singleton &#123; public static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Singleton s1 = null; Singleton s2 = null; Singleton s3 = Singleton.getInstance(); Singleton s4 = Singleton.getInstance(); if (s3==s4)&#123; System.out.println(\"通过静态工厂获取到的单例是唯一的\"); &#125;else &#123; System.out.println(\"静态工厂获取的单例不唯一\"); &#125; Constructor&lt;?&gt; constructor = Singleton.class.getDeclaredConstructors()[0]; constructor.setAccessible(true); try &#123; s1 = (Singleton) constructor.newInstance(); s2 = (Singleton) constructor.newInstance(); if(s1!=s2)&#123; System.out.println(\"构造出两个不同的实例\"); &#125;else &#123; System.out.println(\"始终为单例\"); &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举实现单例，这个是effective java书中推荐的实现方式，枚举天然私有构造，final，static等特性，可以生产一个懒加载的单例123456public enum Singletons &#123; INSTANCE; public void say() &#123; System.out.println(\"animal say\"); &#125;&#125; 从网上找的一个具体的例子，SomeThing.INSTANCE.getInstance() 即可获得所要实例12345678910111213class Resource&#123;&#125;public enum SomeThing &#123; INSTANCE; private Resource instance; SomeThing() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用构建器（二）","slug":"考虑使用构建器","date":"2017-12-03T06:58:47.000Z","updated":"2017-12-03T14:50:25.000Z","comments":true,"path":"2017/12/03/考虑使用构建器/","link":"","permalink":"http://yoursite.com/2017/12/03/考虑使用构建器/","excerpt":"","text":"考虑使用构建器这个比较好理解，能够解决多参数构造器的复杂性，相对于get和set的JavaBean来说也有线程安全性的优势，个人倾向于使用lombok的@Builder注解，注解虽好用，不过也需要了解下注解背后的一些原理。 先看一下我写的一个简单示例 12345678910111213@Builderpublic class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person p = Person.builder().age(15).build(); &#125; &#125; 再看下官方的标准示例 1234567891011//使用lombok注解的import lombok.Builder;import java.util.Set;@Builderpublic class BuilderExample &#123; private String name; private int age; @Singular private Set&lt;String&gt; occupations;&#125; 等效代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Set;class BuilderExample &#123; private String name; private int age; private Set&lt;String&gt; occupations; BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123; this.name = name; this.age = age; this.occupations = occupations; &#125; public static BuilderExampleBuilder builder() &#123; return new BuilderExampleBuilder(); &#125; public static class BuilderExampleBuilder &#123; private String name; private int age; private java.util.ArrayList&lt;String&gt; occupations; BuilderExampleBuilder() &#123; &#125; public BuilderExampleBuilder name(String name) &#123; this.name = name; return this; &#125; public BuilderExampleBuilder age(int age) &#123; this.age = age; return this; &#125; public BuilderExampleBuilder occupation(String occupation) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.add(occupation); return this; &#125; public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.addAll(occupations); return this; &#125; public BuilderExampleBuilder clearOccupations() &#123; if (this.occupations != null) &#123; this.occupations.clear(); &#125; return this; &#125; public BuilderExample build() &#123; // complicated switch statement to produce a compact properly sized immutable set omitted. // go to https://projectlombok.org/features/Singular-snippet.html to see it. Set&lt;String&gt; occupations = ...; return new BuilderExample(name, age, occupations); &#125; @java.lang.Override public String toString() &#123; return \"BuilderExample.BuilderExampleBuilder(name = \" + this.name + \", age = \" + this.age + \", occupations = \" + this.occupations + \")\"; &#125; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用静态工厂方法代替构造器（一）","slug":"考虑使用静态工厂方法代替构造器","date":"2017-11-30T11:58:47.000Z","updated":"2017-12-03T14:23:05.000Z","comments":true,"path":"2017/11/30/考虑使用静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2017/11/30/考虑使用静态工厂方法代替构造器/","excerpt":"","text":"考虑用静态工厂方法代替构造器优点它们有名称 指的是方法的名称，能够准确描述返回的对象，对于多个构造方法的类可以使用不同的名称来描述返回对象 对于构造方法参数的含义需要结合注释才能明白用哪一个构造器，并且多构造器的时候无法确切知道使用哪个构造器 12345678910111213141516171819202122232425262728293031323334package com.stardust.effective.role1;/** * Created by mike on 2017/12/3. * 它们有名称 */public class Fruit &#123; private String color; private String size; private Fruit(String color,String size)&#123; this.color=color; this.size=size; &#125; /** * 通过方法名可以知道要构造什么样的对象 * @return */ public static Fruit getBigGreenFruit()&#123; return new Fruit(\"green\",\"big\"); &#125; public static Fruit getSmallRedFruit()&#123; return new Fruit(\"red\",\"small\"); &#125; public static Fruit getApple()&#123; return new Fruit(\"red\",\"middle\"); &#125;&#125; 不必每次调用的时候都创建一个新对象单例模式，对于一些不可变类可以使用这种方式，在上面那个例子中我对构造函数进行了私有化，可以认为是一个简单的单例，但还是需要升级优化，在后面单例的几种写法中展开说。这种方式的一个优势即不必重复创建对象，在spring中大量使用单例这种设计模式来创建单一不可变对象。书中还提到一个如果实例受控则可以通过==来判定是否为同一实例，这种写法比equals提升了性能。 术语：实例受控的类(instance-controlled)：在某个时刻只能有某些规定的该类的实例存在。 可以返回原返回类型的任何子类型的对象文章中是以Collections为例的，一开始没有太理解，Collections是一个工具类，构造私有化的，不能直接实例化，Collection本身是接口，不能有静态工厂方法，所以委托给Collections这个工具类来提供生产构造.下面贴一段Collection中静态工厂的例子，以List为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns an immutable list containing only the specified object. * The returned list is serializable. * * @param &lt;T&gt; the class of the objects in the list * @param o the sole object to be stored in the returned list. * @return an immutable list containing only the specified object. * @since 1.3 */public static &lt;T&gt; List&lt;T&gt; singletonList(T o) &#123; return new SingletonList&lt;&gt;(o);&#125;/** * @serial include */private static class SingletonList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; private static final long serialVersionUID = 3093736618740652951L; private final E element; SingletonList(E obj) &#123;element = obj;&#125; public Iterator&lt;E&gt; iterator() &#123; return singletonIterator(element); &#125; public int size() &#123;return 1;&#125; public boolean contains(Object obj) &#123;return eq(obj, element);&#125; public E get(int index) &#123; if (index != 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: 1\"); return element; &#125; // Override default methods for Collection @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; action.accept(element); &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; throw new UnsupportedOperationException(); &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; throw new UnsupportedOperationException(); &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return singletonSpliterator(element); &#125;&#125;``` 术语：基于接口的框架(interface-based framework)：框架的对外访问与接入渠道是基于接口实现的。#### 在创建参数化类型实例的时候，使代码更加简洁``` java// 当前做法Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();// 举例这样做会更简洁Map&lt;String, List&lt;String&gt;&gt; map = HashMap.newInstance();// java8已经可以直接这样写了Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 缺点类如果不含public或者protected的构造器, 就不能被子类化 例如Collections类，不能被子类化，另一方面就是相当于鼓励复合（Composition），类似于用Collections这类的写法 无法与其他静态方法区分，不像构造方法名称必须为类名，可以使用一些惯用的名称来弥补这一劣势 valueOf() : 类型转换方法, 返回的实例与参数具有相同的值. of() : valueOf()的一种更简洁的替代. getInstance(): 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例. newInstance(): 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同. getType() : 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用. newType() : 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"Mark Down语法","slug":"Markdown语法","date":"2017-11-29T09:39:59.000Z","updated":"2017-11-29T09:43:33.000Z","comments":true,"path":"2017/11/29/Markdown语法/","link":"","permalink":"http://yoursite.com/2017/11/29/Markdown语法/","excerpt":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多","text":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"博客使用示例","slug":"博客使用说明","date":"2017-11-27T12:42:25.000Z","updated":"2017-12-03T06:15:22.000Z","comments":true,"path":"2017/11/27/博客使用说明/","link":"","permalink":"http://yoursite.com/2017/11/27/博客使用说明/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo s More info: Server Generate static files1$ hexo g More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","categories":[],"tags":[]}]}