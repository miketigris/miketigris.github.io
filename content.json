{"meta":{"title":"博客","subtitle":"技术博客","description":"许贵荣","author":"许贵荣个人版权所有","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringBoot官方文档翻译（十三）：Starters","slug":"Spring BootDoc第三部分/SpringBoot翻译（十三）Starters","date":"2018-04-19T05:31:47.000Z","updated":"2018-04-19T03:51:45.888Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十三）Starters/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十三）Starters/","excerpt":"","text":"13.5 Starters1234567Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa dependency in your project.","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十二）：Gradle&Ant","slug":"Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant","date":"2018-04-19T04:31:47.000Z","updated":"2018-04-19T03:50:34.141Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十二）Gradle&Ant/","excerpt":"","text":"13.3 Gradle12To learn about using Spring Boot with Gradle, please refer to the documentation for Spring Boot’s Gradle plugin: 学习在Spring Boot中使用Gradle请转到如下Spring Boot的Gradle插件关联文档中：（https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/gradle-plugin/reference/html/） 13.4 Ant12345It is possible to build a Spring Boot project using Apache Ant+Ivy. The spring-boot-antlib “AntLib” module is also available to help Ant create executable jars.To declare dependencies, a typical ivy.xml file looks something like the following example: 您同样可以使用Apache的Ant配合Ivy去构建Spring Boot工程。spring-boot-antlib 的“AntLib”模块同样可以帮助Ant创建可执行的jars包。声明依赖，一个典型的ivy.xml文件如下：1234567891011&lt;ivy-module version=\"2.0\"&gt; &lt;info organisation=\"org.springframework.boot\" module=\"spring-boot-sample-ant\" /&gt; &lt;configurations&gt; &lt;conf name=\"compile\" description=\"everything needed to compile this module\" /&gt; &lt;conf name=\"runtime\" extends=\"compile\" description=\"everything needed to run this module\" /&gt; &lt;/configurations&gt; &lt;dependencies&gt; &lt;dependency org=\"org.springframework.boot\" name=\"spring-boot-starter\" rev=\"$&#123;spring-boot.version&#125;\" conf=\"compile\" /&gt; &lt;/dependencies&gt;&lt;/ivy-module&gt; 1A typical build.xml looks like the following example: 一个典型的build.xml如下： 123456789101112131415161718192021222324252627282930313233&lt;project xmlns:ivy=&quot;antlib:org.apache.ivy.ant&quot; xmlns:spring-boot=&quot;antlib:org.springframework.boot.ant&quot; name=&quot;myapp&quot; default=&quot;build&quot;&gt; &lt;property name=&quot;spring-boot.version&quot; value=&quot;2.1.0.BUILD-SNAPSHOT&quot; /&gt; &lt;target name=&quot;resolve&quot; description=&quot;--&gt; retrieve dependencies with ivy&quot;&gt; &lt;ivy:retrieve pattern=&quot;lib/[conf]/[artifact]-[type]-[revision].[ext]&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;classpaths&quot; depends=&quot;resolve&quot;&gt; &lt;path id=&quot;compile.classpath&quot;&gt; &lt;fileset dir=&quot;lib/compile&quot; includes=&quot;*.jar&quot; /&gt; &lt;/path&gt; &lt;/target&gt; &lt;target name=&quot;init&quot; depends=&quot;classpaths&quot;&gt; &lt;mkdir dir=&quot;build/classes&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;compile&quot; depends=&quot;init&quot; description=&quot;compile&quot;&gt; &lt;javac srcdir=&quot;src/main/java&quot; destdir=&quot;build/classes&quot; classpathref=&quot;compile.classpath&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;build&quot; depends=&quot;compile&quot;&gt; &lt;spring-boot:exejar destfile=&quot;build/myapp.jar&quot; classes=&quot;build/classes&quot;&gt; &lt;spring-boot:lib&gt; &lt;fileset dir=&quot;lib/runtime&quot; /&gt; &lt;/spring-boot:lib&gt; &lt;/spring-boot:exejar&gt; &lt;/target&gt;&lt;/project&gt; 123If you do not want to use the spring-boot-antlib module, see the Section 86.9, “Build an Executable Archive from Ant without Using spring-boot-antlib” “How-to” . 如果您不想使用spring-boot-antlib模块，请直接看章节86.9“Build an Executable Archive from Ant without Using spring-boot-antlib”","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十一）：使用Spring Boot&Maven","slug":"Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot","date":"2018-04-19T03:31:47.000Z","updated":"2018-04-19T03:31:12.818Z","comments":true,"path":"2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/19/Spring BootDoc第三部分/SpringBoot翻译（十一）使用Spring Boot/","excerpt":"","text":"Part III. Using Spring Boot（使用Spring Boot）1234567This section goes into more detail about how you should use Spring Boot. It covers topics such as build systems, auto-configuration, and how to run your applications. We also cover some Spring Boot best practices. Although there is nothing particularly special about Spring Boot (it is just another library that you can consume), there are a few recommendations that, when followed, make your development process a little easier. 本部分介绍了更多的关于您如何使用Spring Boot的细节。它涵盖了构建系统，自动配置，如何运行您的应用等主题。我们同样涉及了Spring Boot的最佳实践。尽管Spring Boot并没有什么非常特别的东西（它仅仅是您可消费的另一个库而已），接下去，有一些建议，可以使您的部署进程变得更加简单。 13. Build Systems（构建系统）123456It is strongly recommended that you choose a build system that supports dependency management and that can consume artifacts published to the “Maven Central” repository. We would recommend that you choose Maven or Gradle. It is possible to get Spring Boot to work with other build systems (Ant, for example), but they are not particularly well supported. 我们强烈推荐您选择一款构建系统支持依赖管理的，并且能够发布到“Maven Central”库。我们推荐您选择Maven或者Gradle。当然，Spring Boot也同样能够作用于诸如Ant等构建工具，但是对于他们的支持并不是全面的。 13.1 Dependency Management（依赖管理）123456Each release of Spring Boot provides a curated list of dependencies that it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration, as Spring Boot manages that for you. When you upgrade Spring Boot itself, these dependencies are upgraded as well in a consistent way. Spring Boot的每个发行版都提供了一个它支持的依赖关系的策划列表。基于实践，在您的构建配置中您不需要为任何依赖提供一个版本。因为Spring Boot为您管理这些版本。当您升级Spring Boot本身的时候，这些依赖版本会以一致的方式很好的自动升级。 12You can still specify a version and override Spring Boot’s recommendations if you need to do so. 如果您愿意的话，您依然可以指定一个版本覆盖Spring Boot建议的版本。 1234The curated list contains all the spring modules that you can use with Spring Boot as well as a refined list of third party libraries. The list is available as a standard Bills of Materials (spring-boot- dependencies) that can be used with both Maven and Gradle. 这个策划列表包含了所有的您可以配合Spring Boot 使用的spring模块和一个精简的第三方库。这个列表可以作为一个标准的材料清单（spring-boot-dependencies）用于Maven或者Gradle。 12Each release of Spring Boot is associated with a base version of the Spring Framework. We highly recommend that you not specify its version 每一个发布的Spring Boot版本会关联Spring的一个基础版本。我们高度推荐您不要自定义它的版本。 13.2 Maven123Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults. The parent project provides the following features: Maven用户可以继承spring-boot-starter-parent 工程去获得合理的默认值。该父工程提供了如下的功能： 123456789• Java 1.8 as the default compiler level.• UTF-8 source encoding.• A Dependency Management section, inherited from the spring-boot-dependencies pom, that manages the versions of common dependencies. This dependency management lets you omit &lt;version&gt; tags for those dependencies when used in your own pom.• Sensible resource filtering.• Sensible plugin configuration (exec plugin, Git commit ID, and shade).• Sensible resource filtering for application.properties and application.yml including profile-specific files (for example, application-dev.properties and application-dev.yml) java 1.8作为默认的编译等级 UTF-8作为源编码字符集 依赖管理部分，继承于spring-boot-dependencies pom管理基础依赖版本。这种依赖管理能够让您在您的pom中忽略标签。 恰到好处的资源过滤 恰如其分的插件配置(exec plugin, Git commit ID, and shade) 通过profile—specific为application.properties和application.yml做恰当的资源文件过滤（例如application-dev.properties 和 application-dev.yml） 1234Note that, since the application.properties and application.yml files accept Spring style placeholders ($&#123;… &#125;), the Maven filtering is changed to use @..@placeholders. (You can override that by setting a Maven property called resource.delimiter.) 注意，因为application.properties 和 application.yml文件接收Spring风格的占位符（${… })，Maven过滤器变成使用@..@占位符。（您可以通过resource.delimiter文件设置Maven的属性覆盖maven的占位符。 13.2.1 Inheriting the Starter Parent（继承父Starter）12To configure your project to inherit from the spring-boot-starter-parent, set the parent as follows: 配置您的工程去继承spring-boot-starter-parent，设置父pom如下： 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 123You should need to specify only the Spring Boot version number on this dependency. If you import additional starters, you can safely omit the version number. 你仅仅只需要再依赖中定义Spring Boot的版本号。如果您想导入额外的starters，您可以安全的忽略版本号。1234With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to upgrade to another Spring Data release train, you would add the following to your pom.xml: 用那个设置，您依然可以通过复写属性覆盖个人的依赖，例如，升级到另一个Spring Data的升级版，您可以增加以下配置到您的pom.xml中：123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 1Check the spring-boot-dependencies pom for a list of supported properties. 检查spring-boot-dependencies pom（https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-dependencies/pom.xml）以获取支持的属性列表 13.2.2 Using Spring Boot without the Parent POM（不使用父POM）123Not everyone likes inheriting from the spring-boot-starter-parent POM. You may have your own corporate standard parent that you need to use or you may prefer to explicitly declare all your Maven configuration. 并不是每个人都喜欢用继承于spring-boot-starter-parent POM的方式。您可能需要使用您自己的团队标准的父POM，又或者您更愿意明确声明您所有的Maven配置 123If you do not want to use the spring-boot-starter-parent, you can still keep the benefit of the dependency management (but not the plugin management) by using a scope=import dependency, as follows: 如果您不愿使用spring-boot-starter-parent，您仍然可以通过使用scope=import依赖来保留依赖管理的价值，如下： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 123456The preceding sample setup does not let you override individual dependencies by using a property, as explained above. To achieve the same result, you need to add an entry in the dependencyManagement of your project before the spring-boot-dependencies entry. For instance, to upgrade to another Spring Data release train, you could add the following element to your pom.xml: 如上所述，上述示例设置不会让您通过使用属性覆盖个人依赖关系。为了达到同样目标，您需要在dependencyManagement中的spring-boot-dependencies前使用一个节点。举个例子，升级另一个Spring Data 发行版本，您可以增加如下的元素到您的pom.xml中12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 12In the preceding example, we specify a BOM, but any dependency type can be overridden in the same way. 在之前的例子中，我们定义了一个清单，但是任何的依赖类型都能够以这种方式进行覆盖。 13.2.3 Using the Spring Boot Maven Plugin123Spring Boot includes a Maven plugin that can package the project as an executable jar. Add the plugin to your &lt;plugins&gt; section if you want to use it, as shown in the following example: Spring Boot引入了一个Maven的插件，可以打包工程，使之成为一个可执行jar。如果您想使用它的话，增加该插件到部分。如下展示的示例： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 123If you use the Spring Boot starter parent pom, you need to add only the plugin. There is no need to configure it unless you want to change the settings defined in the parent. 如果您使用父POM的方式，您仅仅只需要增加这个插件就可以了。不需要配置它，除非您想改变父POM定义的配置。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第三部分","slug":"SpringBoot官方文档翻译第三部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第三部分/"}]},{"title":"SpringBoot官方文档翻译（十）：创建一个可执行jar包","slug":"SpringBootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包","date":"2018-04-18T08:59:47.000Z","updated":"2018-04-18T09:15:21.363Z","comments":true,"path":"2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包/","link":"","permalink":"http://yoursite.com/2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（十）创建一个可执行jar包/","excerpt":"","text":"11.5 Creating an Executable Jar（运行示例）12345We finish our example by creating a completely self-contained executable jar file that we could run in production. Executable jars (sometimes called “fat jars”) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run. 我们通过创建一个完全独立的可执行JAR文件来完成我们的示例，我们可以在生产中运行它。可执行jars（有时候也叫做“重量级jars”）是包含了您自身编译的类和其所依赖的所有jar包的一个整合归档包。 Executable jars and Java1234567891011Java does not provide a standard way to load nested jar files (jar files that are themselves contained within a jar). This can be problematic if you are looking to distribute a self-contained application. To solve this problem, many developers use “uber” jars. An uber jar packages all the classes from all the application’s dependencies into a single archive. The problem with this approach is that it becomes hard to see which libraries are in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars.Spring Boot takes a different approach and lets you actually nest jars directly. Java并不提供一个标准的方式去嵌套jar文件（jar文件本身又包含另一个jar）。这将成为一个阻碍，如果您打算发布一个独立运行的jar应用。为了解决这个问题，很多开发者使用“uber”包。一个“uber”包根据应用的依赖关系打包了所有的类到一个单独的归档中。采用这种途径打包之后产生的另一个问题是，您无法知道在您的应用中有哪些库。这还产生一个新的问题就是一些同名的文件会被应用到多个不同的（但包含不同的内容)jars当中。Spring Boot 采用了一个不同的方式让您可以直接嵌套jars包。123To create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependenciessection: 创建一个可执行jar，我们需要增减一个spring-boot-maven-plugin到pom文件中。可以这样做，插入下面的配置行到依赖关系部分下面。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1234The spring-boot-starter-parent POM includes &lt;executions&gt; configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details. spring-boot-starter-parent的pom文件包含配置，可以绑定执行repackage对象。如果您不使用父POM，您需要自己声明这个配置。您可以在plugin的文档中得到更为详细的信息（https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/maven-plugin/usage.html） 1Save your pom.xml and run mvn package from the command line, as follows: 保存您的pom.xml,在命令行中运行mvn package，如下：123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.1.0.BUILD-SNAPSHOT:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 1234If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows: 如果您在target目录下查看，你将会看到myproject-0.0.1-SNAPSHOT.jar。这个文件大概10M左右的样子。如果您想一窥内部构造，您可以使用 jar tvf命令，如下： 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 1234You should also see a much smaller file named myproject-0.0.1- SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot. To run that application, use the java -jar command, as follows: 您应该同样的会看到一个比较小的名称为myproject-0.0.1-SNAPSHOT.jar.original的文件在target目录下。这是maven在Spring Boot进行repackaged之前创建的原版的jar文件。运行这个应用，使用java -jar命令，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.0.BUILD-SNAPSHOT)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 1As before, to exit the application, press ctrl-c. 跟之前一样，如果想退出应用，按ctrl+c 12. What to Read Next（接下去阅读什么）12345Hopefully, this section provided some of the Spring Boot basics and got you on your way to writing your own applications. If you are a task-oriented type of developer, you might want to jump over to spring.io and check out some of the getting started guides that solve specific “How do I do that with Spring?” problems. We also have Spring Boot-specific “How-to” reference documentation. 希望，本节提供了一些Spring Boot的基础知识和能帮助您以您自己的方式编写自己的应用程序。如果您是一个面向任务的开发人员类型，您可能想跳到spring.io并查看一些入门指南解决具体的“我怎样用Spring做这件事”的问题。 我们也具有特定于Spring Boot的“操作方法”参考文档。 123The Spring Boot repository also has a bunch of samples you can run. The samples are independent of the rest of the code (that is, you do not need to build the rest to run or use the samples). Spring Boot存储库还有一堆你可以运行的样本。样本与代码的其余部分无关（即，您无需要构建其余的代码去运行或使用样本）123Otherwise, the next logical step is to read Part III, “Using Spring Boot”. If you are really impatient, you could also jump ahead and read about Spring Boot features. 除此之外，下一个合乎逻辑的步骤是阅读第三部分，“使用Spring Boot”。如果您真的不耐烦，您可以跳过此章节，阅读Spring Boot的功能部分。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（九）：运行示例","slug":"SpringBootDoc第二部分/SpringBoot翻译（九）运行示例","date":"2018-04-18T07:32:47.000Z","updated":"2018-04-18T09:15:15.066Z","comments":true,"path":"2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（九）运行示例/","link":"","permalink":"http://yoursite.com/2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（九）运行示例/","excerpt":"","text":"11.4 Running the Example（运行示例）12345At this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following: 此时，您的应用程序应该可以工作了。由于使用了spring-boot-starter-parent POM，所以您有一个可用的运行目标，可以用来启动应用程序。在工程的根木兰路下输入mvn spring-boot:run启动应用。您应该看到类似于以下的输出：12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.0.BUILD-SNAPSHOT)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 12If you open a web browser to localhost:8080, you should see the following output: 如果您打开一个web浏览器输入localhost:8080，您将会看到如下的输出： 1Hello World! 1To gracefully exit the application, press ctrl-c. 优雅退出请按ctrl+c","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（八）：开始写代码","slug":"SpringBootDoc第二部分/SpringBoot翻译（八）开始写代码","date":"2018-04-18T03:56:47.000Z","updated":"2018-04-18T09:15:08.051Z","comments":true,"path":"2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（八）开始写代码/","link":"","permalink":"http://yoursite.com/2018/04/18/SpringBootDoc第二部分/SpringBoot翻译（八）开始写代码/","excerpt":"","text":"11.3 Writing the Code（开始写代码）1234To finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code: 为了完成我们的应用，我们需要创建一个单独的java文件夹。默认情况下，maven从src/main/java中编译源码，因此，您需要创建一个类似于此的文件结构目录并加入您的示例类src/main/java/Example.java并包含以下代码 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 12Although there is not much code here, quite a lot is going on. We step through the important parts in the next few sections. 尽管并没有多少代码，但很多事情静静的发生了。我们将在接下来的章节，带您一步一步解开它的神秘面纱。 11.3.1 The @RestController and @RequestMapping Annotations12345The first annotation on our Example class is @RestController. This is known as a stereotype annotation. It provides hints for people reading the code and for Spring that the class plays a specific role. In this case, our class is a web @Controller, so Spring considers it when handling incoming web requests. 在我们Example类的第一个注解是@RestController。这被认为是一个刻板的注解。它为大家提供了直接的提示，并且告诉Spring容器，被注解的这个类扮演了一个特殊的角色。在这个例子李，我们的类是一个web类型的@Controller，所以Spring会注意到这点，并将web请求交给该类来处理。 1234The @RequestMapping annotation provides “routing” information. It tells Spring that any HTTP request with the / path should be mapped to the home method. The@RestController annotation tells Spring to render the resulting string directly back to the caller. @RequestMapping注解提供了“路由”信息。它告诉Sring，任何的HTTP以/结尾的请求需要映射到home方法上。@RestController注解告诉Spring将结果字符串直接返回给调用方。 123The @RestController and @RequestMapping annotations are Spring MVC annotations. (They are not specific to Spring Boot.) See the MVC sectionin the Spring Reference Documentation for more details. @RestController和@RequestMapping这两个注解是Spring MVC的注解，并非专门为Spring Boot提供的。您可以到Spring官方文档的MVC相关的章节去获取更多的信息。 11.3.2 The @EnableAutoConfiguration Annotation123456The second class-level annotation is @EnableAutoConfiguration. This annotation tells Spring Boot to “guess” how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. 第二个类级别注解@EnableAutoConfiguration，这个注解告诉Spring Boot 去“猜”您是想怎样配置Spring，基于您已经添加的jar包依赖。因为spring-boot-starter-web包含了Tomcat和Spring MVC，auto-configuration自动配置会推断您想开发一个web应用并据此设定Spring相关配置。12345Starters and Auto-ConfigurationAuto-configuration is designed to work well with “Starters”, but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters. Spring Boot still does its best to auto-configure your application. “Starters”和“Auto-Configuration”自动配置的设计是为了更好的配合“Starters”运作，但是两个概念并不直接相关。您可以自由的挑选不在“Starters”中的jar依赖。Spring Boot依然尽最大努力为您的应用做自动配置。 11.3.3 The “main” Method （”main“方法）123456789The final part of our application is the main method. This is just a standard method that follows the Java convention for an application entry point. Our main method delegates to Spring Boot’s SpringApplication class by calling run. SpringApplication bootstraps our application, starting Spring, which, in turn, starts the auto-configured Tomcat web server. We need to pass Example.class as an argument to the run method to tell SpringApplication which is the primary Spring component. The args array is also passed through to expose any command-line arguments. 本节的最后一部分介绍我们应用的”main“方法。这只是遵循Java约定的标准方法应用程序入口点。我们的main方法会调用给Spring Boot的SpringApplication类的run方法。SpringApplication引导我们的应用程序，从Spring开始，启动自动配置的Tomcat Web服务器。我们需要将Example.class作为run方法的一个参数，去通知SpringApplication，这是Spring的主要组件。该参数数组同样可以通过任何暴露的命令行参数进行传递。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（七）：增加类路径依赖","slug":"SpringBootDoc第二部分/SpringBoot翻译（七）增加类路径依赖","date":"2018-04-17T12:35:47.000Z","updated":"2018-04-18T09:15:00.028Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（七）增加类路径依赖/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（七）增加类路径依赖/","excerpt":"","text":"11.2 Adding Classpath Dependencies（增加类路径依赖）123456Spring Boot provides a number of “Starters” that let you add jars to your classpath. Our sample application has already used spring-boot-starter-parent in the parent section of the POM. The spring-boot-starter-parent is a special starter that provides useful Maven defaults. It also provides a dependency-management section so that you can omit version tags for “blessed” dependencies. Spring Boot 提供了一些“Starters”用于您增加一些jars包到您的类路径下。我们的示例应用已经使用了spring-boot-starter-parent在上一节的POM文件中。spring-boot-starter-parent是一个提供了非常有用的Maven默认的特殊的starter。它同样提供了一个dependency-management部分，以便于您可以为一些“幸福”依赖忽略版本标签。 12345Other “Starters” provide dependencies that you are likely to need when developing a specific type of application. Since we are developing a web application, we add a spring-boot-starter-web dependency. Before that, we can look at what we currently have by running the following command: 其他“Starters”提供了一些依赖，以便于您可以在开发一些特殊模式的应用，如果我们需要部署一个web应用，我们需要增加 spring-boot-starter-web的依赖。在此之前，我们可以使用以下命令寻找我们目前已有的依赖：123$ mvn dependency:tree[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT 12345The mvn dependency:tree command prints a tree representation of your project dependencies. You can see that spring-boot-starter-parent provides no dependencies by itself. To add the necessary dependencies, edit your pom.xml and add the spring-boot-starter-web dependency immediately below the parent section: mvn dependency:tree命令会将您的应用依赖以树形展示。您可以发现spring-boot-starter-parent本身并不提供任何依赖。如果需要增加必要的依赖，更改您的pom.xml，增加spring-boot-starter-web依赖紧接在父节点下面：123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123If you run mvn dependency:tree again, you see that there are now a number of additional dependencies, including the Tomcat web server and Spring Boot itself. 如果您再次运行mvn dependency:tree，您将会看到一系列的新增的依赖，包括tomcat服务器和Spring Boot本身","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（六）：创建POM文件","slug":"SpringBootDoc第二部分/SpringBoot翻译（六）创建POM文件","date":"2018-04-17T12:15:47.000Z","updated":"2018-04-18T09:14:54.260Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（六）创建POM文件/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（六）创建POM文件/","excerpt":"","text":"11.1 Creating the POM(创建POM文件)123We need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following: 我们需要以创建一个pom.xml文件开始。pom.xml是用于构建项目的配方。 打开您最喜欢的文本编辑器并添加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 123The preceding listing should give you a working build. You can test it by running mvn package (for now, you can ignore the “jar will be empty - no content was marked for inclusion!” warning). 上面的列表应该已经给了您一个可工作的构建。您可以使用mvn package来运行测试它（现在，你可以忽略“jar will be empty - no content was marked for inclusion!“的警告）123At this point, you could import the project into an IDE (most modern Java IDEs include built-in support for Maven). For simplicity, we continue to use a plain text editor for this example. 在此刻，您可以导入该工程到IDE（所有的流行的javaIDE都支持导入Maven项目）。为了简化，我们继续使用纯文本编辑器编辑示例。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（四）：安装Spring Boot命令行界面","slug":"SpringBootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI","date":"2018-04-17T11:58:47.000Z","updated":"2018-04-18T09:14:39.764Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（四）安装部署Spring Boot CLI/","excerpt":"","text":"10.2 Installing the Spring Boot CLI（安装Spring Boot命令行界面）1234567The Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code.You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI（命令行界面）是一个命令行工具，您可以使用它来快速使用Spring进行原型开发它允许您运行Groovy脚本，这意味着您不需要太多样板代码就能以类似于java的语法进行开发。尽管您不需要使用CLI去运行Spring Boot ，但这绝对是获得Spring应用程序的最快捷方式 10.2.1 Manual Installation（手动安装）12345678910You can download the Spring CLI distribution from the Spring software repository: • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip • spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gzCutting edge snapshot distributions are also available.Once downloaded, follow the INSTALL.txt instructions from the unpacked archive. In summary, there is a spring script (spring.bat for Windows) in a bin/directory in the .zip file. Alternatively, you can use java -jar with the .jar file (the script helps you to be sure that the classpath is set correctly). 您可以从Spring 软件远程库下载Spring CLI的分发版本• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.zip• spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin.tar.gz最新的快照版本同样可用。下载以后，请参照解压出来的文档INSTALL.txt的介绍进行操作。综上所述，有一个spring脚本（windows 下用spring.bat）在bin目录下的.zip文件中。另外，你可以使用java -jar 启动.jar包（这个脚本帮助您确认类路径是否被正确设置） 10.2.2 Installation with SDKMAN!（通过SDKMAN安装）1234SDKMAN! (The Software Development Kit Manager) can be used for managing multiple versions of various binary SDKs, including Groovy and the Spring Boot CLI. Get SDKMAN! from sdkman.io and install Spring Boot by using the following commands: SDKMAN!（软件开发工具包管理器）可用于管理各种二进制SDK的多个版本，包括Groovy脚本和Spring Boot CLI.从sdkman.io中获取SDKMAN!并用以下命令进行Spring Boot 安装。123$ sdk install springboot$ spring --versionSpring Boot v2.1.0.BUILD-SNAPSHOT 12If you develop features for the CLI and want easy access to the version you built, use the following commands: 如果您为CLI开发功能并希望轻松访问您创建的版本，请使用以下命令： 12345$ sdk install springboot dev /path/to/spring-boot/spring-boot-cli/ target/spring-boot-cli-2.1.0.BUILD-SNAPSHOT-bin/spring-2.1.0.BUILD-SNAPSHOT/$ sdk default springboot dev$ spring --versionSpring CLI v2.1.0.BUILD-SNAPSHOT 12The preceding instructions install a local instance of spring called the dev instance. It points at your target build location, so every time you rebuild Spring Boot,spring is up-to-date.You can see it by running the following command: 之前介绍了如何安装一个被称之为dev实例的本地spring实例。它指向了您的目标构建地址，因此每次当您重新构建Spring Boot的时候spring也同步更新。您可以通过运行下列命令行查看它： 12345678910111213$ sdk ls springboot================================================================================Available Springboot Versions================================================================================&gt; + dev* 2.1.0.BUILD-SNAPSHOT================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 10.2.3 OSX Homebrew Installation(苹果系统下使用Homebrew安装）12If you are on a Mac and use Homebrew, you can install the Spring Boot CLI by using the following commands: 如果您使用的是Mac并且使用Homebrew命令，你可以安装Spring Boot CLI 通过以下命令： 12$ brew tap pivotal/tap$ brew install springboot 1Homebrew installs spring to /usr/local/bin. Homebrew将spring安装在/usr/local/bin路径下 12If you do not see the formula, your installation of brew might be out-of-date. In that case, run brew update and try again. 如果您没有看到该公式，那么您的brew的安装可能会过时。 在这种情况下，运行brew update并重试。 10.2.4 MacPorts Installation（以MacPorts安装方式）12If you are on a Mac and use MacPorts, you can install the Spring Boot CLI by using the following command: 如果您使用Mac，并且使用MacPorts，您可以通过以下命令安装Spring Boot CLI1$ sudo port install spring-boot-cli 10.2.5 Command-line Completion（命令行完成）123456789The Spring Boot CLI includes scripts that provide command completion for the BASH and zsh shells. You can source the script (also named spring) in any shell or put it in your personal or system-wide bash completion initialization. On a Debian system, the system-wide scripts are in /shell-completion/bash and all scripts in that directory are executed when a new shell starts. For example, to run the script manually if you have installed by using SDKMAN!, use the following commands: Spring Boot CLI为BASH和zsh shells提供了命令行完成脚本。您可以在任何shell或者您个人的或者系统范围内的bash中初始化source该脚本。在Debian系统，全系统脚本在/shell-completion/bash，并且所有新建的可执行脚本都在该路径下。比如说，在您已经安装使用SDKMAN的情况下，去手动运行该脚本，使用如下命令：123$ . ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring$ spring &lt;HIT TAB HERE&gt; grab help jar run test version 123If you install the Spring Boot CLI by using Homebrew or MacPorts, the command-line completion scripts are automatically registered with your shell. 如果您使用Homebrew或者MacPorts安装Spring Boot CLI命令行初始化完成，那么它会自动注册到您的shell当中。 10.2.6 Quick-start Spring CLI Example（快速开始Spring CLI 示例）12You can use the following web application to test your installation. To start, create a file called app.groovy, as follows: 您可以使用如下的web应用去测试您的安装情况。首先，创建一个如下的app.groovy： 123456789@RestControllerclass ThisWillActuallyRun &#123; @RequestMapping(\"/\") String home() &#123; \"Hello World!\" &#125;&#125; 1Then run it from a shell, as follows: 然后在shell中运行它，如下：1$ spring run app.groovy 12The first run of your application is slow, as dependencies are downloaded. Subsequent runs are much quicker. 首次运行您的应用会比较慢，因为依赖库需要被下载，以后每次运行会比较快12Open localhost:8080 in your favorite web browser. You should see the following output: 在您喜爱的浏览器中打开 localhost:8080 ，您将会看到如下的输出： 1Hello World! 10.3 Upgrading from an Earlier Version of Spring Boot（从一个旧版本升级Spring Boot）1234If you are upgrading from an earlier release of Spring Boot, check the “migration guide” on the project wiki that provides detailed upgrade instructions. Check also the“release notes” for a list of “new and noteworthy” features for each release. 如果您想从以前的版本中升级Spring Boot 请核对该项目在wiki上的“migration guide”，它提供了详细的升级说明。并且从列表中核对“relese notes”，每个relese版本都有新的值得注意的功能。 12345To upgrade an existing CLI installation, use the appropriate package manager command (for example, brew upgrade) or, if you manually installed the CLI, follow thestandard instructions, remembering to update your PATH environment variable to remove any older references. 去升级一个已有的CLI安装程序，推荐使用打包工具命令（比如 brew upgrage），如果您手动安装了CLI，根据标准的说明，记得更新您的环境变量去移除任何旧的关联","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（五）：部署你的第一个Spring Boot应用","slug":"SpringBootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用","date":"2018-04-17T11:50:47.000Z","updated":"2018-04-18T09:14:48.245Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（五）部署你的第一个Spring Boot应用/","excerpt":"","text":"11. Developing Your First Spring Boot Application(部署你的第一个Spring Boot应用)123This section describes how to develop a simple “Hello World!” web application that highlights some of Spring Boot’s key features. We use Maven to build this project, since most IDEs support it. 本节讲述了如何部署一个简单的”Hello World”的Web应用，突出讲述了一些Spring Boot的关键功能。我们使用Maven去构建这个工程，因为大多数IDE支持它。 1234567The spring.io web site contains many “Getting Started” guides that use Spring Boot. If you need to solve a specific problem, check there first.You can shortcut the steps below by going to start.spring.io and choosing the &quot;Web&quot; starter from the dependencies searcher. Doing so generates a new project structure so that you can start coding right away. Check the Spring Initializr documentation for more details. spring.io网站包含了很多使用Spring Boot的“入门”向导。如果你需要解决一个特殊的问题，可以首先从那里寻找答案。您可以通过start.spring.io从依赖中找到“Web starter”来简化以下步骤。这样做会产生一个新的项目结构，以便您可以立即开始编码。查看Spring Initializr文档以获取更多详细信息。 12Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed: 在我们开始之前，打开terminal窗口，运行以下指令去确认您是否安装有符合版本的java和maven1234$ java -versionjava version \"1.8.0_102\"Java(TM) SE Runtime Environment (build 1.8.0_102-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) 1234$ mvn -vApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00)Maven home: /usr/local/Cellar/maven/3.3.9/libexecJava version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory. 此示例需要在其自己的文件夹中创建。随后说明假定您已经创建了合适的文件夹和它是你当前的目录。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（三）：安装部署Spring Boot","slug":"SpringBootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot","date":"2018-04-17T02:59:47.000Z","updated":"2018-04-18T09:14:33.700Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（三）安装部署Spring Boot/","excerpt":"","text":"10. Installing Spring Boot（安装部署Spring Boot）123456789Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Either way, you need Java SDK v1.8 or higher. Before you begin, you should check your current Java installation by using the following command: $ java -version If you are new to Java development or if you want to experiment with Spring Boot, you might want to try the Spring Boot CLI (Command Line Interface) first. Otherwise, read on for “classic” installation instructions. Spring Boot 可以被传统的java部署工具部署，也可以被安装为命令行工具。同样的，您需要java1.8或更高的版本支持。在您开始之前，您可以使用如下命令检查一下您的JDK版本1$ java -version 如果您是新部署一个应用或者您想尝试下Spring Boot ，您可以首先尝试使用Spring Boot CLI（命令行接口）。否则，请阅读“传统”安装介绍。 10.1 Installation Instructions for the Java Developer（针对java开发者的安装介绍）12345678910You can use Spring Boot in the same way as any standard Java library. To do so, include the appropriate spring-boot-*.jar files on your classpath. Spring Boot does not require any special tools integration, so you can use any IDE or text editor. Also, there is nothing special about a Spring Boot application, so you can run and debug a Spring Boot application as you would any other Java program. Although you could copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle). 您可以同样的使用Spring Boot作为一个标准的Java库。因此，您可以讲spring-boot-*.jar适当的引入到您的类路径下。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。并且，Spring Boot应用没有任何特殊之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。尽管您可以拷贝Spring Boot jar包，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。 10.1.1 Maven Installation（Maven下的安装）12Spring Boot is compatible with Apache Maven 3.2 or above. If you do not already have Maven installed, you can follow the instructions at maven.apache.org. Spring Boot与Apache Maven 3.2或更高版本兼容。 如果你尚未安装Maven，您可以按照maven.apache.org上的说明进行操作。 12345On many operating systems, Maven can be installed with a package manager. If you use OSX Homebrew, try brew install maven. Ubuntu users can run sudo apt-get install maven. Windows users with Chocolatey can run choco install maven from an elevated (administrator) prompt. 在很多系统中，Maven可以使用包管理器进行安装。如果您使用OSX系统的Homebrew，尝试brew install maven。Ubuntu用户可以运行 sudo apt-get 安装maven。 具有Chocolatey命令行管理包的Window用户可以以管理员的身份在示框中运行choco install maven 123456Spring Boot dependencies use the org.springframework.boot groupId. Typically, your Maven POM file inherits from the spring-boot-starter- parentproject and declares dependencies to one or more “Starters”. Spring Boot also provides an optional Maven plugin to create executable jars. The following listing shows a typical pom.xml file: Spring Boot 依赖使用 org.springframework.boot 作为groupId。通常，您的Maven POM文件继承于spring-boot-starter-parentproject 并且声明依赖于一个或者多个“Straters”。Sring Boot同样提供了可选的Maven插件去创建可运行jars包。以下列表展示了一个通常使用的pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- Add Spring repositories --&gt; &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 10.1.2 Gradle Installation（Gradle下的安装）1234567Spring Boot is compatible with Gradle 4. If you do not already have Gradle installed, you can follow the instructions at gradle.org.Spring Boot dependencies can be declared by using the org.springframework.boot group. Typically, your project declares dependencies to one or more“Starters”. Spring Boot provides a useful Gradle plugin that can be used to simplify dependency declarations and to create executable jars. Spring Boot 兼容Gradle 4. 如果您还没有安装Gradle，您可以从 gradle.org中获取介绍文档。Spring Boot依赖可以被声明为org.springframework.boot group。通常，您的项目被声明依赖于一个或者多个“Strarters”。Spring Boot 提供可用的Gradle 插件用于简化依赖声明和创建可执行jars包。 12345Gradle WrapperThe Gradle Wrapper provides a nice way of “obtaining” Gradle when you need to build a project. It is a small script and library that you commit alongside your code to bootstrap the build process. See docs.gradle.org/4.2.1/userguide/gradle_wrapper.html for details. Gradle 包装当您去构建您的应用时，Gradle 包装提供了一个优雅的路径去“获得”Gradle。他提供了一个小脚本和库似的您的提交和构建同步进行。具体参见：docs.gradle.org/4.2.1/userguide/gradle_wrapper.html 1The following example shows a typical build.gradle file: 以下为一个通常的build.gradle文件 123456789101112131415161718192021222324252627282930buildscript &#123; repositories &#123; jcenter() maven &#123; url 'https://repo.spring.io/snapshot' &#125; maven &#123; url 'https://repo.spring.io/milestone' &#125; &#125; dependencies &#123; classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.1.0.BUILD-SNAPSHOT' &#125;&#125;apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter() maven &#123; url \"https://repo.spring.io/snapshot\" &#125; maven &#123; url \"https://repo.spring.io/milestone\" &#125;&#125;dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-web\") testCompile(\"org.springframework.boot:spring-boot-starter-test\")&#125;","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（二）：系统依赖","slug":"SpringBootDoc第二部分/SpringBoot翻译（二）系统依赖","date":"2018-04-17T02:58:47.000Z","updated":"2018-04-18T09:14:27.917Z","comments":true,"path":"2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（二）系统依赖/","link":"","permalink":"http://yoursite.com/2018/04/17/SpringBootDoc第二部分/SpringBoot翻译（二）系统依赖/","excerpt":"","text":"9 . System Requirements（系统依赖）123Spring Boot 2.1.0.BUILD-SNAPSHOT requires Java 8 or 9 and Spring Framework 5.0.5.RELEASE or above. Explicit build support is provided for Maven 3.2+ and Gradle 4. Spring Boot 2.1。0.BUILD-SNAPSHOT 需要java8或者java9版本，以及Spring Framework 5.0.5.RELEASE 或更高版本。为Maven 3.2+和Gradle 4提供了明确的支持。 9.1 Servlet Containers（Servlet 容器）1Spring Boot supports the following embedded servlet containers: Spring Boot支持如下内置容器 Name Servlet Version Tomcat 8.5 3.1 Jetty 9.4 3.1 Undertow 1.4 3.1 1You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 您也可以部署Spring Boot应用在任何的基于Servlet 3.1+版本的容器中","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"SpringBoot官方文档翻译（一）：介绍 Spring Boot","slug":"SpringBootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot","date":"2018-04-16T14:58:47.000Z","updated":"2018-04-18T09:14:19.317Z","comments":true,"path":"2018/04/16/SpringBootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot/","link":"","permalink":"http://yoursite.com/2018/04/16/SpringBootDoc第二部分/SpringBoot翻译（一）介绍 Spring Boot/","excerpt":"","text":"Part II. Getting Started篇章二. 开始123456If you are getting started with Spring Boot,or “Spring” in general, start by reading this section. It answers the basic “what?”, “how?” and “why?” questions.It includes an introduction to Spring Boot, along with installation instructions.We then walk you through building your first Spring Boot application, discussing some core principles as we go. 一般来说，您可以从阅读本章节开始学习Spring Boot 或者Spring。本节回答了最基础的“什么？”，“如何？”，“为何？”等问题。它包括了介绍Spring Boot如何独立部署的说明。我们将带领您建设您得第一个SpringBoot应用，跟随我们一起去探讨一些Spring Boot的核心价值。 8 . Introducing Spring Boot（介绍 Spring Boot）12345Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使您能够非常简单的创建一个可运行的基于Spring的，产品级别的，独立部署应用。我们用我们自己认为的观点来处理Spring平台和第三方库，以便于您能够以最小的代价开始您的应用。所有的Spring Boot应用都只需要很少的Spring配置123You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. 你能够在Spring Boot 中使用java -jar 或者更为传统的 war包去创建java应用。我们同样提供了命令行工具去运行“Spring脚本”。12345678910Our primary goals are:* Provide a radically faster and widely accessible getting-started experience for all Spring development.* Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.* Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).* Absolutely no code generation and no requirement for XML configuration. 我们的主要目标 • 为所有的基于Spring的开发提供一个更快的，更广泛的入门级体验。 • 以自我认为的方式通过一些默认的最快速基本的配置实现开箱即用的体验。 • 提供大型项目（如内置服务器，安全性，埋点，运行状况检查和外部配置）通用的一系列非产品功能性的功能。 • 绝对不需要生成代码或者xml的配置。","categories":[{"name":"SpringBoot官方文档翻译","slug":"SpringBoot官方文档翻译","permalink":"http://yoursite.com/categories/SpringBoot官方文档翻译/"}],"tags":[{"name":"SpringBoot官方文档翻译第二部分","slug":"SpringBoot官方文档翻译第二部分","permalink":"http://yoursite.com/tags/SpringBoot官方文档翻译第二部分/"}]},{"title":"消除过期的对象引用（六）","slug":"读书笔记/消除过期的对象引用","date":"2017-12-04T14:19:47.000Z","updated":"2017-12-04T15:27:51.000Z","comments":true,"path":"2017/12/04/读书笔记/消除过期的对象引用/","link":"","permalink":"http://yoursite.com/2017/12/04/读书笔记/消除过期的对象引用/","excerpt":"","text":"消除过期的对象引用书中的例子如下:问题出在pop方法上，pop出去以后，stack的size本身减少1，size–，外部会持有该对象的引用，但是即便外部释放掉该element的引用，stack本身还有一个“保护机制”，栈内部会维护着这个对象的过期引用。为什么呢？这个是数组的特性，好比创建了一个16大小的数组，调用pop方法相当于这时候对第16个数组对象创建一个外部引用，这个对象本身还是在内存中有空间的。换而言之，这个第16个对象此时此刻即被外部调用的一个引用持有，也同时被stack本身的数组持有，也许有人认为–size了，现在应该变为15大小的数组了，为什么还持有第16个呢？这里首先要理解数组对象创建的时候内存的变化。声明数组过程中，变量保存在栈中，创建并进行初始化时，数组元素是保存在堆中，数组通过引用指针指向数组元素。对于基本类型数组的初始化，程序直接先为数组分配内存空间，再将数组元素的值存入对应的内存里。对于引用类型数组的数组元素依然是引用类型，因此数组元素里存储的还是引用，它指向另一块内存，该内在里存储了该引用变量所引用的对象。这里的size其实只是栈中一个域变量的变化，而非真正数组的变化，原来作为基本类型的引用依然存在于第16个数组的位置上。 1234567891011121314151617181920212223242526public class Stack &#123; pprivate Object[] elements; private int size = 0; private static final int DEFAULT_INITAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if(size == 0) &#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 术语：过期引用（obsolete reference) ，指永远不会被解除的引用。 书中也给了修改得方式如下：12345678public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; Object result = elements[--size]; elements[size] = null; return result;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"私有化构造函数强化不可实例化的类，避免创建不必要的对象（四，五）","slug":"读书笔记/通过私有化构造函数强化不可实例化的类","date":"2017-12-04T11:19:47.000Z","updated":"2017-12-04T15:26:55.000Z","comments":true,"path":"2017/12/04/读书笔记/通过私有化构造函数强化不可实例化的类/","link":"","permalink":"http://yoursite.com/2017/12/04/读书笔记/通过私有化构造函数强化不可实例化的类/","excerpt":"","text":"通过私有化构造函数强化不可实例化的类这个个人理解就是因为有默认构造函数的原因，如果是显示声明私有化的话则不可实例化，或者只能通过本身来提供实例。但是对于某些工具类，如Collections，更希望即便在内部也不要私有化，书中给出一种方案，我们一Collections类为例 1234// Suppresses default constructor, ensuring non-instantiability.private Collections() &#123; throw new AssertionError();//可有可以无，但是有的情况下，可以有效防止内部不小心实例化&#125; 避免创建不必要的对象其实鼓励能够使用单例的或者静态工厂的尽量使用，这样可以少创建无用对象，这样能减轻垃圾回收的压力，可以很好的提升性能。 1234String s = new String(\"stringette\");//这种写法会制造不必要的String实例,\"stringette\"本身就是一个实例，再使用new会再创建一个实例String ss = \"stringette\"; //这种写法会复用一个实例，即便在多次调用的情况下，该实例被保存在字符串常量池中 可以参考下这篇文章：https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html 优先使用基本类型，而非装箱类型，这里装箱的时候回产生新的对象。下面这个例子测试时间分别为8483ms和775ms相差有10倍之多123456789101112131415161718192021222324252627package com.stardust.effective.role4And5;/** * Created by mike on 2017/12/4. */public class LongTest &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //获取开始时间 Long sum = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i; &#125; long middle = System.currentTimeMillis(); //获取中间时间 System.out.println(middle-start); long sum2 = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum2 += i; &#125; long end = System.currentTimeMillis(); //获取结束时间 System.out.println(end-middle); &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"用私有构造器或者枚举强化单例（三）","slug":"读书笔记/用私有构造器或者枚举强化单例","date":"2017-12-03T14:58:47.000Z","updated":"2017-12-04T11:20:25.000Z","comments":true,"path":"2017/12/03/读书笔记/用私有构造器或者枚举强化单例/","link":"","permalink":"http://yoursite.com/2017/12/03/读书笔记/用私有构造器或者枚举强化单例/","excerpt":"","text":"用私有构造器或者枚举强化单例首先对单单例，构造函数需要私有化，这样能够极大的保障外部无法直接实例化该对象单例在面试中经常会有面试官要求写，下面列出几种常用的写法： 懒汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 12345678910 public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 1234567 public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 对于上面这种写法，在书中有提到如果首行代码是public的话可以通过反射机制多实例化对象。如下举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.stardust.effective.role3;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by mike on 2017/12/3. */public class Singleton &#123; public static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Singleton s1 = null; Singleton s2 = null; Singleton s3 = Singleton.getInstance(); Singleton s4 = Singleton.getInstance(); if (s3==s4)&#123; System.out.println(\"通过静态工厂获取到的单例是唯一的\"); &#125;else &#123; System.out.println(\"静态工厂获取的单例不唯一\"); &#125; Constructor&lt;?&gt; constructor = Singleton.class.getDeclaredConstructors()[0]; constructor.setAccessible(true); try &#123; s1 = (Singleton) constructor.newInstance(); s2 = (Singleton) constructor.newInstance(); if(s1!=s2)&#123; System.out.println(\"构造出两个不同的实例\"); &#125;else &#123; System.out.println(\"始终为单例\"); &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举实现单例，这个是effective java书中推荐的实现方式，枚举天然私有构造，final，static等特性，可以生产一个懒加载的单例123456public enum Singletons &#123; INSTANCE; public void say() &#123; System.out.println(\"animal say\"); &#125;&#125; 从网上找的一个具体的例子，SomeThing.INSTANCE.getInstance() 即可获得所要实例12345678910111213class Resource&#123;&#125;public enum SomeThing &#123; INSTANCE; private Resource instance; SomeThing() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用构建器（二）","slug":"读书笔记/考虑使用构建器","date":"2017-12-03T06:58:47.000Z","updated":"2017-12-03T14:50:25.000Z","comments":true,"path":"2017/12/03/读书笔记/考虑使用构建器/","link":"","permalink":"http://yoursite.com/2017/12/03/读书笔记/考虑使用构建器/","excerpt":"","text":"考虑使用构建器这个比较好理解，能够解决多参数构造器的复杂性，相对于get和set的JavaBean来说也有线程安全性的优势，个人倾向于使用lombok的@Builder注解，注解虽好用，不过也需要了解下注解背后的一些原理。 先看一下我写的一个简单示例 12345678910111213@Builderpublic class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person p = Person.builder().age(15).build(); &#125; &#125; 再看下官方的标准示例 1234567891011//使用lombok注解的import lombok.Builder;import java.util.Set;@Builderpublic class BuilderExample &#123; private String name; private int age; @Singular private Set&lt;String&gt; occupations;&#125; 等效代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Set;class BuilderExample &#123; private String name; private int age; private Set&lt;String&gt; occupations; BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123; this.name = name; this.age = age; this.occupations = occupations; &#125; public static BuilderExampleBuilder builder() &#123; return new BuilderExampleBuilder(); &#125; public static class BuilderExampleBuilder &#123; private String name; private int age; private java.util.ArrayList&lt;String&gt; occupations; BuilderExampleBuilder() &#123; &#125; public BuilderExampleBuilder name(String name) &#123; this.name = name; return this; &#125; public BuilderExampleBuilder age(int age) &#123; this.age = age; return this; &#125; public BuilderExampleBuilder occupation(String occupation) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.add(occupation); return this; &#125; public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.addAll(occupations); return this; &#125; public BuilderExampleBuilder clearOccupations() &#123; if (this.occupations != null) &#123; this.occupations.clear(); &#125; return this; &#125; public BuilderExample build() &#123; // complicated switch statement to produce a compact properly sized immutable set omitted. // go to https://projectlombok.org/features/Singular-snippet.html to see it. Set&lt;String&gt; occupations = ...; return new BuilderExample(name, age, occupations); &#125; @java.lang.Override public String toString() &#123; return \"BuilderExample.BuilderExampleBuilder(name = \" + this.name + \", age = \" + this.age + \", occupations = \" + this.occupations + \")\"; &#125; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用静态工厂方法代替构造器（一）","slug":"读书笔记/考虑使用静态工厂方法代替构造器","date":"2017-11-30T11:58:47.000Z","updated":"2017-12-03T14:23:05.000Z","comments":true,"path":"2017/11/30/读书笔记/考虑使用静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2017/11/30/读书笔记/考虑使用静态工厂方法代替构造器/","excerpt":"","text":"考虑用静态工厂方法代替构造器优点它们有名称 指的是方法的名称，能够准确描述返回的对象，对于多个构造方法的类可以使用不同的名称来描述返回对象 对于构造方法参数的含义需要结合注释才能明白用哪一个构造器，并且多构造器的时候无法确切知道使用哪个构造器 12345678910111213141516171819202122232425262728293031323334package com.stardust.effective.role1;/** * Created by mike on 2017/12/3. * 它们有名称 */public class Fruit &#123; private String color; private String size; private Fruit(String color,String size)&#123; this.color=color; this.size=size; &#125; /** * 通过方法名可以知道要构造什么样的对象 * @return */ public static Fruit getBigGreenFruit()&#123; return new Fruit(\"green\",\"big\"); &#125; public static Fruit getSmallRedFruit()&#123; return new Fruit(\"red\",\"small\"); &#125; public static Fruit getApple()&#123; return new Fruit(\"red\",\"middle\"); &#125;&#125; 不必每次调用的时候都创建一个新对象单例模式，对于一些不可变类可以使用这种方式，在上面那个例子中我对构造函数进行了私有化，可以认为是一个简单的单例，但还是需要升级优化，在后面单例的几种写法中展开说。这种方式的一个优势即不必重复创建对象，在spring中大量使用单例这种设计模式来创建单一不可变对象。书中还提到一个如果实例受控则可以通过==来判定是否为同一实例，这种写法比equals提升了性能。 术语：实例受控的类(instance-controlled)：在某个时刻只能有某些规定的该类的实例存在。 可以返回原返回类型的任何子类型的对象文章中是以Collections为例的，一开始没有太理解，Collections是一个工具类，构造私有化的，不能直接实例化，Collection本身是接口，不能有静态工厂方法，所以委托给Collections这个工具类来提供生产构造.下面贴一段Collection中静态工厂的例子，以List为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns an immutable list containing only the specified object. * The returned list is serializable. * * @param &lt;T&gt; the class of the objects in the list * @param o the sole object to be stored in the returned list. * @return an immutable list containing only the specified object. * @since 1.3 */public static &lt;T&gt; List&lt;T&gt; singletonList(T o) &#123; return new SingletonList&lt;&gt;(o);&#125;/** * @serial include */private static class SingletonList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; private static final long serialVersionUID = 3093736618740652951L; private final E element; SingletonList(E obj) &#123;element = obj;&#125; public Iterator&lt;E&gt; iterator() &#123; return singletonIterator(element); &#125; public int size() &#123;return 1;&#125; public boolean contains(Object obj) &#123;return eq(obj, element);&#125; public E get(int index) &#123; if (index != 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: 1\"); return element; &#125; // Override default methods for Collection @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; action.accept(element); &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; throw new UnsupportedOperationException(); &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; throw new UnsupportedOperationException(); &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return singletonSpliterator(element); &#125;&#125;``` 术语：基于接口的框架(interface-based framework)：框架的对外访问与接入渠道是基于接口实现的。#### 在创建参数化类型实例的时候，使代码更加简洁``` java// 当前做法Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();// 举例这样做会更简洁Map&lt;String, List&lt;String&gt;&gt; map = HashMap.newInstance();// java8已经可以直接这样写了Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 缺点类如果不含public或者protected的构造器, 就不能被子类化 例如Collections类，不能被子类化，另一方面就是相当于鼓励复合（Composition），类似于用Collections这类的写法 无法与其他静态方法区分，不像构造方法名称必须为类名，可以使用一些惯用的名称来弥补这一劣势 valueOf() : 类型转换方法, 返回的实例与参数具有相同的值. of() : valueOf()的一种更简洁的替代. getInstance(): 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例. newInstance(): 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同. getType() : 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用. newType() : 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"Mark Down语法","slug":"Markdown语法","date":"2017-11-29T09:39:59.000Z","updated":"2017-11-29T09:43:33.000Z","comments":true,"path":"2017/11/29/Markdown语法/","link":"","permalink":"http://yoursite.com/2017/11/29/Markdown语法/","excerpt":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多","text":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"博客使用示例","slug":"博客使用说明","date":"2017-11-27T12:42:25.000Z","updated":"2017-12-03T06:15:22.000Z","comments":true,"path":"2017/11/27/博客使用说明/","link":"","permalink":"http://yoursite.com/2017/11/27/博客使用说明/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo s More info: Server Generate static files1$ hexo g More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","categories":[],"tags":[]}]}