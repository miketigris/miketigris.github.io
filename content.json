{"meta":{"title":"博客","subtitle":"技术博客","description":"许贵荣","author":"许贵荣个人版权所有","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"覆盖equals时请遵守通用约定（八）","slug":"覆盖equals时请遵守通用约定md","date":"2017-12-04T15:11:47.000Z","updated":"2017-12-04T15:14:56.000Z","comments":true,"path":"2017/12/04/覆盖equals时请遵守通用约定md/","link":"","permalink":"http://yoursite.com/2017/12/04/覆盖equals时请遵守通用约定md/","excerpt":"","text":"覆盖equals时请遵守通用约定","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"避免使用终结方法（七）","slug":"避免使用终结方法","date":"2017-12-04T14:55:47.000Z","updated":"2017-12-04T15:28:16.000Z","comments":true,"path":"2017/12/04/避免使用终结方法/","link":"","permalink":"http://yoursite.com/2017/12/04/避免使用终结方法/","excerpt":"","text":"避免使用终结方法什么是终结方法？finalize()。为什么要避免使用？个人建议不要知道为什么吧。。。知道了又不能用，如果你实在想知道，可以参考下面这个人的blog。http://www.jianshu.com/p/fdeb5fd573dc","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"消除过期的对象引用（六）","slug":"消除过期的对象引用","date":"2017-12-04T14:19:47.000Z","updated":"2017-12-04T15:27:51.000Z","comments":true,"path":"2017/12/04/消除过期的对象引用/","link":"","permalink":"http://yoursite.com/2017/12/04/消除过期的对象引用/","excerpt":"","text":"消除过期的对象引用书中的例子如下:问题出在pop方法上，pop出去以后，stack的size本身减少1，size–，外部会持有该对象的引用，但是即便外部释放掉该element的引用，stack本身还有一个“保护机制”，栈内部会维护着这个对象的过期引用。为什么呢？这个是数组的特性，好比创建了一个16大小的数组，调用pop方法相当于这时候对第16个数组对象创建一个外部引用，这个对象本身还是在内存中有空间的。换而言之，这个第16个对象此时此刻即被外部调用的一个引用持有，也同时被stack本身的数组持有，也许有人认为–size了，现在应该变为15大小的数组了，为什么还持有第16个呢？这里首先要理解数组对象创建的时候内存的变化。声明数组过程中，变量保存在栈中，创建并进行初始化时，数组元素是保存在堆中，数组通过引用指针指向数组元素。对于基本类型数组的初始化，程序直接先为数组分配内存空间，再将数组元素的值存入对应的内存里。对于引用类型数组的数组元素依然是引用类型，因此数组元素里存储的还是引用，它指向另一块内存，该内在里存储了该引用变量所引用的对象。这里的size其实只是栈中一个域变量的变化，而非真正数组的变化，原来作为基本类型的引用依然存在于第16个数组的位置上。 1234567891011121314151617181920212223242526public class Stack &#123; pprivate Object[] elements; private int size = 0; private static final int DEFAULT_INITAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if(size == 0) &#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 术语：过期引用（obsolete reference) ，指永远不会被解除的引用。 书中也给了修改得方式如下：12345678public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; Object result = elements[--size]; elements[size] = null; return result;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"私有化构造函数强化不可实例化的类，避免创建不必要的对象（四，五）","slug":"通过私有化构造函数强化不可实例化的类","date":"2017-12-04T11:19:47.000Z","updated":"2017-12-04T15:26:55.000Z","comments":true,"path":"2017/12/04/通过私有化构造函数强化不可实例化的类/","link":"","permalink":"http://yoursite.com/2017/12/04/通过私有化构造函数强化不可实例化的类/","excerpt":"","text":"通过私有化构造函数强化不可实例化的类这个个人理解就是因为有默认构造函数的原因，如果是显示声明私有化的话则不可实例化，或者只能通过本身来提供实例。但是对于某些工具类，如Collections，更希望即便在内部也不要私有化，书中给出一种方案，我们一Collections类为例 1234// Suppresses default constructor, ensuring non-instantiability.private Collections() &#123; throw new AssertionError();//可有可以无，但是有的情况下，可以有效防止内部不小心实例化&#125; 避免创建不必要的对象其实鼓励能够使用单例的或者静态工厂的尽量使用，这样可以少创建无用对象，这样能减轻垃圾回收的压力，可以很好的提升性能。 1234String s = new String(\"stringette\");//这种写法会制造不必要的String实例,\"stringette\"本身就是一个实例，再使用new会再创建一个实例String ss = \"stringette\"; //这种写法会复用一个实例，即便在多次调用的情况下，该实例被保存在字符串常量池中 可以参考下这篇文章：https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html 优先使用基本类型，而非装箱类型，这里装箱的时候回产生新的对象。下面这个例子测试时间分别为8483ms和775ms相差有10倍之多123456789101112131415161718192021222324252627package com.stardust.effective.role4And5;/** * Created by mike on 2017/12/4. */public class LongTest &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //获取开始时间 Long sum = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i; &#125; long middle = System.currentTimeMillis(); //获取中间时间 System.out.println(middle-start); long sum2 = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum2 += i; &#125; long end = System.currentTimeMillis(); //获取结束时间 System.out.println(end-middle); &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"用私有构造器或者枚举强化单例（三）","slug":"用私有构造器或者枚举强化单例","date":"2017-12-03T14:58:47.000Z","updated":"2017-12-04T11:20:25.000Z","comments":true,"path":"2017/12/03/用私有构造器或者枚举强化单例/","link":"","permalink":"http://yoursite.com/2017/12/03/用私有构造器或者枚举强化单例/","excerpt":"","text":"用私有构造器或者枚举强化单例首先对单单例，构造函数需要私有化，这样能够极大的保障外部无法直接实例化该对象单例在面试中经常会有面试官要求写，下面列出几种常用的写法： 懒汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 12345678910 public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式（线程不安全写法，与之相对的还有线程安全的写法不赘述） 1234567 public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 对于上面这种写法，在书中有提到如果首行代码是public的话可以通过反射机制多实例化对象。如下举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.stardust.effective.role3;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by mike on 2017/12/3. */public class Singleton &#123; public static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Singleton s1 = null; Singleton s2 = null; Singleton s3 = Singleton.getInstance(); Singleton s4 = Singleton.getInstance(); if (s3==s4)&#123; System.out.println(\"通过静态工厂获取到的单例是唯一的\"); &#125;else &#123; System.out.println(\"静态工厂获取的单例不唯一\"); &#125; Constructor&lt;?&gt; constructor = Singleton.class.getDeclaredConstructors()[0]; constructor.setAccessible(true); try &#123; s1 = (Singleton) constructor.newInstance(); s2 = (Singleton) constructor.newInstance(); if(s1!=s2)&#123; System.out.println(\"构造出两个不同的实例\"); &#125;else &#123; System.out.println(\"始终为单例\"); &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举实现单例，这个是effective java书中推荐的实现方式，枚举天然私有构造，final，static等特性，可以生产一个懒加载的单例123456public enum Singletons &#123; INSTANCE; public void say() &#123; System.out.println(\"animal say\"); &#125;&#125; 从网上找的一个具体的例子，SomeThing.INSTANCE.getInstance() 即可获得所要实例12345678910111213class Resource&#123;&#125;public enum SomeThing &#123; INSTANCE; private Resource instance; SomeThing() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用构建器（二）","slug":"考虑使用构建器","date":"2017-12-03T06:58:47.000Z","updated":"2017-12-03T14:50:25.000Z","comments":true,"path":"2017/12/03/考虑使用构建器/","link":"","permalink":"http://yoursite.com/2017/12/03/考虑使用构建器/","excerpt":"","text":"考虑使用构建器这个比较好理解，能够解决多参数构造器的复杂性，相对于get和set的JavaBean来说也有线程安全性的优势，个人倾向于使用lombok的@Builder注解，注解虽好用，不过也需要了解下注解背后的一些原理。 先看一下我写的一个简单示例 12345678910111213@Builderpublic class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person p = Person.builder().age(15).build(); &#125; &#125; 再看下官方的标准示例 1234567891011//使用lombok注解的import lombok.Builder;import java.util.Set;@Builderpublic class BuilderExample &#123; private String name; private int age; @Singular private Set&lt;String&gt; occupations;&#125; 等效代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Set;class BuilderExample &#123; private String name; private int age; private Set&lt;String&gt; occupations; BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123; this.name = name; this.age = age; this.occupations = occupations; &#125; public static BuilderExampleBuilder builder() &#123; return new BuilderExampleBuilder(); &#125; public static class BuilderExampleBuilder &#123; private String name; private int age; private java.util.ArrayList&lt;String&gt; occupations; BuilderExampleBuilder() &#123; &#125; public BuilderExampleBuilder name(String name) &#123; this.name = name; return this; &#125; public BuilderExampleBuilder age(int age) &#123; this.age = age; return this; &#125; public BuilderExampleBuilder occupation(String occupation) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.add(occupation); return this; &#125; public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123; if (this.occupations == null) &#123; this.occupations = new java.util.ArrayList&lt;String&gt;(); &#125; this.occupations.addAll(occupations); return this; &#125; public BuilderExampleBuilder clearOccupations() &#123; if (this.occupations != null) &#123; this.occupations.clear(); &#125; return this; &#125; public BuilderExample build() &#123; // complicated switch statement to produce a compact properly sized immutable set omitted. // go to https://projectlombok.org/features/Singular-snippet.html to see it. Set&lt;String&gt; occupations = ...; return new BuilderExample(name, age, occupations); &#125; @java.lang.Override public String toString() &#123; return \"BuilderExample.BuilderExampleBuilder(name = \" + this.name + \", age = \" + this.age + \", occupations = \" + this.occupations + \")\"; &#125; &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"考虑使用静态工厂方法代替构造器（一）","slug":"考虑使用静态工厂方法代替构造器","date":"2017-11-30T11:58:47.000Z","updated":"2017-12-03T14:23:05.000Z","comments":true,"path":"2017/11/30/考虑使用静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2017/11/30/考虑使用静态工厂方法代替构造器/","excerpt":"","text":"考虑用静态工厂方法代替构造器优点它们有名称 指的是方法的名称，能够准确描述返回的对象，对于多个构造方法的类可以使用不同的名称来描述返回对象 对于构造方法参数的含义需要结合注释才能明白用哪一个构造器，并且多构造器的时候无法确切知道使用哪个构造器 12345678910111213141516171819202122232425262728293031323334package com.stardust.effective.role1;/** * Created by mike on 2017/12/3. * 它们有名称 */public class Fruit &#123; private String color; private String size; private Fruit(String color,String size)&#123; this.color=color; this.size=size; &#125; /** * 通过方法名可以知道要构造什么样的对象 * @return */ public static Fruit getBigGreenFruit()&#123; return new Fruit(\"green\",\"big\"); &#125; public static Fruit getSmallRedFruit()&#123; return new Fruit(\"red\",\"small\"); &#125; public static Fruit getApple()&#123; return new Fruit(\"red\",\"middle\"); &#125;&#125; 不必每次调用的时候都创建一个新对象单例模式，对于一些不可变类可以使用这种方式，在上面那个例子中我对构造函数进行了私有化，可以认为是一个简单的单例，但还是需要升级优化，在后面单例的几种写法中展开说。这种方式的一个优势即不必重复创建对象，在spring中大量使用单例这种设计模式来创建单一不可变对象。书中还提到一个如果实例受控则可以通过==来判定是否为同一实例，这种写法比equals提升了性能。 术语：实例受控的类(instance-controlled)：在某个时刻只能有某些规定的该类的实例存在。 可以返回原返回类型的任何子类型的对象文章中是以Collections为例的，一开始没有太理解，Collections是一个工具类，构造私有化的，不能直接实例化，Collection本身是接口，不能有静态工厂方法，所以委托给Collections这个工具类来提供生产构造.下面贴一段Collection中静态工厂的例子，以List为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns an immutable list containing only the specified object. * The returned list is serializable. * * @param &lt;T&gt; the class of the objects in the list * @param o the sole object to be stored in the returned list. * @return an immutable list containing only the specified object. * @since 1.3 */public static &lt;T&gt; List&lt;T&gt; singletonList(T o) &#123; return new SingletonList&lt;&gt;(o);&#125;/** * @serial include */private static class SingletonList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; private static final long serialVersionUID = 3093736618740652951L; private final E element; SingletonList(E obj) &#123;element = obj;&#125; public Iterator&lt;E&gt; iterator() &#123; return singletonIterator(element); &#125; public int size() &#123;return 1;&#125; public boolean contains(Object obj) &#123;return eq(obj, element);&#125; public E get(int index) &#123; if (index != 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: 1\"); return element; &#125; // Override default methods for Collection @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; action.accept(element); &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; throw new UnsupportedOperationException(); &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; throw new UnsupportedOperationException(); &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return singletonSpliterator(element); &#125;&#125;``` 术语：基于接口的框架(interface-based framework)：框架的对外访问与接入渠道是基于接口实现的。#### 在创建参数化类型实例的时候，使代码更加简洁``` java// 当前做法Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();// 举例这样做会更简洁Map&lt;String, List&lt;String&gt;&gt; map = HashMap.newInstance();// java8已经可以直接这样写了Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 缺点类如果不含public或者protected的构造器, 就不能被子类化 例如Collections类，不能被子类化，另一方面就是相当于鼓励复合（Composition），类似于用Collections这类的写法 无法与其他静态方法区分，不像构造方法名称必须为类名，可以使用一些惯用的名称来弥补这一劣势 valueOf() : 类型转换方法, 返回的实例与参数具有相同的值. of() : valueOf()的一种更简洁的替代. getInstance(): 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例. newInstance(): 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同. getType() : 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用. newType() : 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://yoursite.com/tags/Effective-Java/"}]},{"title":"Mark Down语法","slug":"Markdown语法","date":"2017-11-29T09:39:59.000Z","updated":"2017-11-29T09:43:33.000Z","comments":true,"path":"2017/11/29/Markdown语法/","link":"","permalink":"http://yoursite.com/2017/11/29/Markdown语法/","excerpt":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多","text":"我在mac下用的Markdown编辑器是免费的Lite MWeb，从官方说明上摘抄下语法，以后备用 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"开篇：2018年寄语","slug":"开篇：2018年寄语","date":"2017-11-28T11:58:47.000Z","updated":"2017-12-03T06:29:04.000Z","comments":true,"path":"2017/11/28/开篇：2018年寄语/","link":"","permalink":"http://yoursite.com/2017/11/28/开篇：2018年寄语/","excerpt":"","text":"“天下武功唯快不破” 在过去的2017年忙碌充实，收获满满2017年主要的工作经历都在拍拍贷，在拍拍贷期间完成了整个资金中台的支付核心和支付网关的研发，使用了很多新的技术，Springboot，SpringCloud，Git 很多东西都是第一次接触，一边学习，一边工作，收获满满。再次致谢原阿里“青蜂侠”杨志宏先生带给我的技术视野，让我重新认知了“程序员”的定义，在技术的道路上不仅要拓展深度，还需要要广度，对新技术充满着热情，不断的学习充实自己。当在9月份因为一些原因不得不离开的时候也无太多遗憾。 9月和10月为了面试看了好多书，阿里方腾飞的《并发编程的艺术》，周志明的《深入理解JVM虚拟机》，Eric Evans的《领域驱动设计》，《Springboot实战》《java8实战》《Spring In Action》，《java核心卷一》，翟永超的blog还有他的《Spring Cloud微服务实践》，《微服务设计》等等。这些书籍让我无比充实，越是阅读越是发现自己的鄙陋与无知。对于2018年也定了一些新的书单，坚定不移的用知识和前沿的技术武装自己。 各类武侠小说中都有一句：天下武功唯快不破。这句用在科技行业真是非常恰当的，技术发展日新月异，当一些公司还沾沾自喜于已有的市场，已有的技术时，殊不知新的技术革命已经启程，互联网充满了无尽的想象，绝不止于BAT，新的技术的产生，必会有更多优秀的公司，通过新的技术，对一些庞大的运作效率低下的，一些固守于已有技术的公司进行“降维”打击。我非常幸运的从事着互联网行业，又能接触到诸多的金融知识，希望自己在2018能够把握机遇，事业和理想都能更前一步！ 10月底来到美团，感受到美团强大的技术氛围，在美团这片战场上开启一段新的旅程。最后搭建博客的想法主要还是看了翟永超的博客，做的很不错，创作总是从模仿开始吧，页面的主题等等都是学习借鉴于他的博客。@翟永超的blog ：http://blog.didispace.com/","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客使用示例","slug":"博客使用说明","date":"2017-11-27T12:42:25.000Z","updated":"2017-12-03T06:15:22.000Z","comments":true,"path":"2017/11/27/博客使用说明/","link":"","permalink":"http://yoursite.com/2017/11/27/博客使用说明/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo s More info: Server Generate static files1$ hexo g More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","categories":[],"tags":[]}]}